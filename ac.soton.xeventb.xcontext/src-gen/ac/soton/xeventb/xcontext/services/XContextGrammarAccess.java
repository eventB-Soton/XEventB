/*
 * generated by Xtext 2.24.0
 */
package ac.soton.xeventb.xcontext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class XContextGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class XContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContextAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Keyword cContextKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cExtendsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cExtendsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cExtendsContextCrossReference_4_1_0 = (CrossReference)cExtendsAssignment_4_1.eContents().get(0);
		private final RuleCall cExtendsContextQualifiedNameParserRuleCall_4_1_0_1 = (RuleCall)cExtendsContextCrossReference_4_1_0.eContents().get(1);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Group cGroup_5_0 = (Group)cAlternatives_5.eContents().get(0);
		private final Keyword cSetsKeyword_5_0_0 = (Keyword)cGroup_5_0.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_5_0_1 = (Assignment)cGroup_5_0.eContents().get(1);
		private final RuleCall cOrderedChildrenXCarrierSetParserRuleCall_5_0_1_0 = (RuleCall)cOrderedChildrenAssignment_5_0_1.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cConstantsKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cOrderedChildrenXConstantParserRuleCall_5_1_1_0 = (RuleCall)cOrderedChildrenAssignment_5_1_1.eContents().get(0);
		private final Group cGroup_5_2 = (Group)cAlternatives_5.eContents().get(2);
		private final Keyword cConstantKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_5_2_1 = (Assignment)cGroup_5_2.eContents().get(1);
		private final RuleCall cOrderedChildrenXTypedConstantParserRuleCall_5_2_1_0 = (RuleCall)cOrderedChildrenAssignment_5_2_1.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_5_3 = (Assignment)cAlternatives_5.eContents().get(3);
		private final RuleCall cOrderedChildrenXRecordParserRuleCall_5_3_0 = (RuleCall)cOrderedChildrenAssignment_5_3.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_5_4 = (Assignment)cAlternatives_5.eContents().get(4);
		private final RuleCall cOrderedChildrenXSingleAxiomParserRuleCall_5_4_0 = (RuleCall)cOrderedChildrenAssignment_5_4.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//XContext econtext::Context:
		//	{econtext::Context} comment=STRING?
		//	'context' name=ID ('extends' extends+=[econtext::Context|QualifiedName]+)? ('sets' orderedChildren+=XCarrierSet+ |
		//	'constants' orderedChildren+=XConstant+ | 'constant' orderedChildren+=XTypedConstant | orderedChildren+=XRecord |
		//	orderedChildren+=XSingleAxiom)*
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Context} comment=STRING?
		//'context' name=ID ('extends' extends+=[econtext::Context|QualifiedName]+)? ('sets' orderedChildren+=XCarrierSet+ |
		//'constants' orderedChildren+=XConstant+ | 'constant' orderedChildren+=XTypedConstant | orderedChildren+=XRecord |
		//orderedChildren+=XSingleAxiom)*
		//'end'
		public Group getGroup() { return cGroup; }
		
		//{econtext::Context}
		public Action getContextAction_0() { return cContextAction_0; }
		
		//comment=STRING?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//'context'
		public Keyword getContextKeyword_2() { return cContextKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//('extends' extends+=[econtext::Context|QualifiedName]+)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'extends'
		public Keyword getExtendsKeyword_4_0() { return cExtendsKeyword_4_0; }
		
		//extends+=[econtext::Context|QualifiedName]+
		public Assignment getExtendsAssignment_4_1() { return cExtendsAssignment_4_1; }
		
		//[econtext::Context|QualifiedName]
		public CrossReference getExtendsContextCrossReference_4_1_0() { return cExtendsContextCrossReference_4_1_0; }
		
		//QualifiedName
		public RuleCall getExtendsContextQualifiedNameParserRuleCall_4_1_0_1() { return cExtendsContextQualifiedNameParserRuleCall_4_1_0_1; }
		
		//('sets' orderedChildren+=XCarrierSet+ | 'constants' orderedChildren+=XConstant+ | 'constant'
		//orderedChildren+=XTypedConstant | orderedChildren+=XRecord | orderedChildren+=XSingleAxiom)*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//'sets' orderedChildren+=XCarrierSet+
		public Group getGroup_5_0() { return cGroup_5_0; }
		
		//'sets'
		public Keyword getSetsKeyword_5_0_0() { return cSetsKeyword_5_0_0; }
		
		//orderedChildren+=XCarrierSet+
		public Assignment getOrderedChildrenAssignment_5_0_1() { return cOrderedChildrenAssignment_5_0_1; }
		
		//XCarrierSet
		public RuleCall getOrderedChildrenXCarrierSetParserRuleCall_5_0_1_0() { return cOrderedChildrenXCarrierSetParserRuleCall_5_0_1_0; }
		
		//'constants' orderedChildren+=XConstant+
		public Group getGroup_5_1() { return cGroup_5_1; }
		
		//'constants'
		public Keyword getConstantsKeyword_5_1_0() { return cConstantsKeyword_5_1_0; }
		
		//orderedChildren+=XConstant+
		public Assignment getOrderedChildrenAssignment_5_1_1() { return cOrderedChildrenAssignment_5_1_1; }
		
		//XConstant
		public RuleCall getOrderedChildrenXConstantParserRuleCall_5_1_1_0() { return cOrderedChildrenXConstantParserRuleCall_5_1_1_0; }
		
		//'constant' orderedChildren+=XTypedConstant
		public Group getGroup_5_2() { return cGroup_5_2; }
		
		//'constant'
		public Keyword getConstantKeyword_5_2_0() { return cConstantKeyword_5_2_0; }
		
		//orderedChildren+=XTypedConstant
		public Assignment getOrderedChildrenAssignment_5_2_1() { return cOrderedChildrenAssignment_5_2_1; }
		
		//XTypedConstant
		public RuleCall getOrderedChildrenXTypedConstantParserRuleCall_5_2_1_0() { return cOrderedChildrenXTypedConstantParserRuleCall_5_2_1_0; }
		
		//orderedChildren+=XRecord
		public Assignment getOrderedChildrenAssignment_5_3() { return cOrderedChildrenAssignment_5_3; }
		
		//XRecord
		public RuleCall getOrderedChildrenXRecordParserRuleCall_5_3_0() { return cOrderedChildrenXRecordParserRuleCall_5_3_0; }
		
		///*
		//		 * At the moment, supporting both collection of axioms and individual
		//		 * axiom/theorems cause problem with either ambiguity for the grammar or 
		//		 * quick fixes. In particular, theorem needs to be declared to be a 
		//		 * separate element rather than attributes. 
		//		 */
		////		('axioms' orderedChildren+=XAxiom+) |
		//		orderedChildren+=XSingleAxiom
		public Assignment getOrderedChildrenAssignment_5_4() { return cOrderedChildrenAssignment_5_4; }
		
		//XSingleAxiom
		public RuleCall getOrderedChildrenXSingleAxiomParserRuleCall_5_4_0() { return cOrderedChildrenXSingleAxiomParserRuleCall_5_4_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class XCarrierSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XCarrierSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCarrierSetAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//XCarrierSet econtext::CarrierSet:
		//	{econtext::CarrierSet} comment=STRING?
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::CarrierSet} comment=STRING?
		//name=ID
		public Group getGroup() { return cGroup; }
		
		//{econtext::CarrierSet}
		public Action getCarrierSetAction_0() { return cCarrierSetAction_0; }
		
		//comment=STRING?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class XConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//XConstant econtext::Constant:
		//	{econtext::Constant} comment=STRING?
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Constant} comment=STRING?
		//name=ID
		public Group getGroup() { return cGroup; }
		
		//{econtext::Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }
		
		//comment=STRING?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class XTypedConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XTypedConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTypedConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTypeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTypeXTypeParserRuleCall_3_1_0 = (RuleCall)cTypeAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cEqualsSignKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cValueAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cValueXFormulaParserRuleCall_4_1_0 = (RuleCall)cValueAssignment_4_1.eContents().get(0);
		
		//XTypedConstant eventbcoreex::TypedConstant:
		//	{eventbcoreex::TypedConstant} comment=STRING?
		//	name=ID (':' type=XType)? ('=' value=XFormula)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{eventbcoreex::TypedConstant} comment=STRING?
		//name=ID (':' type=XType)? ('=' value=XFormula)?
		public Group getGroup() { return cGroup; }
		
		//{eventbcoreex::TypedConstant}
		public Action getTypedConstantAction_0() { return cTypedConstantAction_0; }
		
		//comment=STRING?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//(':' type=XType)?
		public Group getGroup_3() { return cGroup_3; }
		
		//':'
		public Keyword getColonKeyword_3_0() { return cColonKeyword_3_0; }
		
		//type=XType
		public Assignment getTypeAssignment_3_1() { return cTypeAssignment_3_1; }
		
		//XType
		public RuleCall getTypeXTypeParserRuleCall_3_1_0() { return cTypeXTypeParserRuleCall_3_1_0; }
		
		//('=' value=XFormula)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'='
		public Keyword getEqualsSignKeyword_4_0() { return cEqualsSignKeyword_4_0; }
		
		//value=XFormula
		public Assignment getValueAssignment_4_1() { return cValueAssignment_4_1; }
		
		//XFormula
		public RuleCall getValueXFormulaParserRuleCall_4_1_0() { return cValueXFormulaParserRuleCall_4_1_0; }
	}
	public class XSingleAxiomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XSingleAxiom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAxiomAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cTheoremAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Keyword cTheoremTheoremKeyword_2_0_0 = (Keyword)cTheoremAssignment_2_0.eContents().get(0);
		private final Keyword cAxiomKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameXLABELTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cPredicateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPredicateXFormulaParserRuleCall_4_0 = (RuleCall)cPredicateAssignment_4.eContents().get(0);
		
		//XSingleAxiom econtext::Axiom:
		//	{econtext::Axiom} comment=STRING? (theorem?='theorem' | 'axiom') name=XLABEL predicate=XFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Axiom} comment=STRING? (theorem?='theorem' | 'axiom') name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//{econtext::Axiom}
		public Action getAxiomAction_0() { return cAxiomAction_0; }
		
		//comment=STRING?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//(theorem?='theorem' | 'axiom')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//theorem?='theorem'
		public Assignment getTheoremAssignment_2_0() { return cTheoremAssignment_2_0; }
		
		//'theorem'
		public Keyword getTheoremTheoremKeyword_2_0_0() { return cTheoremTheoremKeyword_2_0_0; }
		
		//'axiom'
		public Keyword getAxiomKeyword_2_1() { return cAxiomKeyword_2_1; }
		
		//name=XLABEL
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_3_0() { return cNameXLABELTerminalRuleCall_3_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_4() { return cPredicateAssignment_4; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_4_0() { return cPredicateXFormulaParserRuleCall_4_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUNTRANSLATED_TOKENTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//XFormula:
		//	(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT | UNTRANSLATED_TOKEN)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT | UNTRANSLATED_TOKEN)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EVENTB_IDENTIFIER_KEYWORD
		public RuleCall getEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0() { return cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0; }
		
		//EVENTB_PREDICATE_SYMBOLS
		public RuleCall getEVENTB_PREDICATE_SYMBOLSParserRuleCall_1() { return cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1; }
		
		//EVENTB_EXPRESSION_SYMBOLS
		public RuleCall getEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2() { return cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_3() { return cIDTerminalRuleCall_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
		
		//UNTRANSLATED_TOKEN
		public RuleCall getUNTRANSLATED_TOKENTerminalRuleCall_5() { return cUNTRANSLATED_TOKENTerminalRuleCall_5; }
	}
	public class XTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXTypePrimitiveParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cXTYPEOPERATORParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cXTypePrimitiveParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//XType:
		//	XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*;
		@Override public ParserRule getRule() { return rule; }
		
		//XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*
		public Group getGroup() { return cGroup; }
		
		//XTypePrimitive
		public RuleCall getXTypePrimitiveParserRuleCall_0() { return cXTypePrimitiveParserRuleCall_0; }
		
		//(XTYPEOPERATOR XTypePrimitive)*
		public Group getGroup_1() { return cGroup_1; }
		
		//XTYPEOPERATOR
		public RuleCall getXTYPEOPERATORParserRuleCall_1_0() { return cXTYPEOPERATORParserRuleCall_1_0; }
		
		//XTypePrimitive
		public RuleCall getXTypePrimitiveParserRuleCall_1_1() { return cXTypePrimitiveParserRuleCall_1_1; }
	}
	public class XTYPEOPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XTYPEOPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPrivateUseAreaE100Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE101Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE102Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsArrowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithTailWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cMultiplicationSignKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//XTYPEOPERATOR:
		//	'↔' | // Symbols for building set of relations
		//	'' |
		//	'' |
		//	'' |
		//	'⇸' |
		//	'→' |
		//	'⤔' |
		//	'↣' |
		//	'⤀' |
		//	'↠' |
		//	'⤖' |
		//	'×';
		@Override public ParserRule getRule() { return rule; }
		
		//'↔' | // Symbols for building set of relations
		//'' |
		//'' |
		//'' |
		//'⇸' |
		//'→' |
		//'⤔' |
		//'↣' |
		//'⤀' |
		//'↠' |
		//'⤖' |
		//'×'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_0() { return cLeftRightArrowKeyword_0; }
		
		//// Symbols for building set of relations
		//''
		public Keyword getPrivateUseAreaE100Keyword_1() { return cPrivateUseAreaE100Keyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE101Keyword_2() { return cPrivateUseAreaE101Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_3() { return cPrivateUseAreaE102Keyword_3; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_4() { return cRightwardsArrowWithVerticalStrokeKeyword_4; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_5() { return cRightwardsArrowKeyword_5; }
		
		//'⤔'
		public Keyword getRightwardsArrowWithTailWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithTailWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_10() { return cRightwardsTwoHeadedArrowWithTailKeyword_10; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_11() { return cMultiplicationSignKeyword_11; }
	}
	public class XTypePrimitiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XTypePrimitive");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cBOOLKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDoubleStruckCapitalNDigitOneKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDoubleStruckCapitalNKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDoubleStruckCapitalZKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cXTypeParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cDoubleStruckCapitalPKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final RuleCall cXTypeParserRuleCall_6_2 = (RuleCall)cGroup_6.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cDoubleStruckCapitalPDigitOneKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final RuleCall cXTypeParserRuleCall_7_2 = (RuleCall)cGroup_7.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_7_3 = (Keyword)cGroup_7.eContents().get(3);
		
		//XTypePrimitive:
		//	ID |
		//	'BOOL' |
		//	'ℕ1' |
		//	'ℕ' |
		//	'ℤ' |
		//	'(' XType ')' |
		//	'ℙ' '(' XType ')' |
		//	'ℙ1' '(' XType ')';
		@Override public ParserRule getRule() { return rule; }
		
		//ID |
		//'BOOL' |
		//'ℕ1' |
		//'ℕ' |
		//'ℤ' |
		//'(' XType ')' |
		//'ℙ' '(' XType ')' |
		//'ℙ1' '(' XType ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_1() { return cBOOLKeyword_1; }
		
		//'ℕ1'
		public Keyword getDoubleStruckCapitalNDigitOneKeyword_2() { return cDoubleStruckCapitalNDigitOneKeyword_2; }
		
		//'ℕ'
		public Keyword getDoubleStruckCapitalNKeyword_3() { return cDoubleStruckCapitalNKeyword_3; }
		
		//'ℤ'
		public Keyword getDoubleStruckCapitalZKeyword_4() { return cDoubleStruckCapitalZKeyword_4; }
		
		//'(' XType ')'
		public Group getGroup_5() { return cGroup_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_5_1() { return cXTypeParserRuleCall_5_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }
		
		//'ℙ' '(' XType ')'
		public Group getGroup_6() { return cGroup_6; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_6_0() { return cDoubleStruckCapitalPKeyword_6_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6_1() { return cLeftParenthesisKeyword_6_1; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_6_2() { return cXTypeParserRuleCall_6_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6_3() { return cRightParenthesisKeyword_6_3; }
		
		//'ℙ1' '(' XType ')'
		public Group getGroup_7() { return cGroup_7; }
		
		//'ℙ1'
		public Keyword getDoubleStruckCapitalPDigitOneKeyword_7_0() { return cDoubleStruckCapitalPDigitOneKeyword_7_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_1() { return cLeftParenthesisKeyword_7_1; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_7_2() { return cXTypeParserRuleCall_7_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_3() { return cRightParenthesisKeyword_7_3; }
	}
	public class EVENTB_IDENTIFIER_KEYWORDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_IDENTIFIER_KEYWORD");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOOLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFALSEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTRUEKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBoolKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cCardKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDomKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cFiniteKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cIdKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cInterKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMaxKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cMinKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cModKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cPredKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cPrj1Keyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cPrj2Keyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cRanKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cSuccKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cUnionKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cDoubleStruckCapitalNDigitOneKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cDoubleStruckCapitalNKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cDoubleStruckCapitalPDigitOneKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cDoubleStruckCapitalPKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cDoubleStruckCapitalZKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		
		//// IMPORTANT: Do not make these terminal as it can cause problem with the XType
		//EVENTB_IDENTIFIER_KEYWORD:
		//	'BOOL' |
		//	'FALSE' |
		//	'TRUE' |
		//	'bool' |
		//	'card' |
		//	'dom' |
		//	'finite' |
		//	'id' |
		//	'inter' |
		//	'max' |
		//	'min' |
		//	'mod' |
		//	'pred' |
		//	'prj1' |
		//	'prj2' |
		//	'ran' |
		//	'succ' |
		//	'union' |
		//	'ℕ1' |
		//	'ℕ' |
		//	'ℙ1' |
		//	'ℙ' |
		//	'ℤ';
		@Override public ParserRule getRule() { return rule; }
		
		//'BOOL' |
		//'FALSE' |
		//'TRUE' |
		//'bool' |
		//'card' |
		//'dom' |
		//'finite' |
		//'id' |
		//'inter' |
		//'max' |
		//'min' |
		//'mod' |
		//'pred' |
		//'prj1' |
		//'prj2' |
		//'ran' |
		//'succ' |
		//'union' |
		//'ℕ1' |
		//'ℕ' |
		//'ℙ1' |
		//'ℙ' |
		//'ℤ'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_0() { return cBOOLKeyword_0; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_1() { return cFALSEKeyword_1; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_2() { return cTRUEKeyword_2; }
		
		//'bool'
		public Keyword getBoolKeyword_3() { return cBoolKeyword_3; }
		
		//'card'
		public Keyword getCardKeyword_4() { return cCardKeyword_4; }
		
		//'dom'
		public Keyword getDomKeyword_5() { return cDomKeyword_5; }
		
		//'finite'
		public Keyword getFiniteKeyword_6() { return cFiniteKeyword_6; }
		
		//'id'
		public Keyword getIdKeyword_7() { return cIdKeyword_7; }
		
		//'inter'
		public Keyword getInterKeyword_8() { return cInterKeyword_8; }
		
		//'max'
		public Keyword getMaxKeyword_9() { return cMaxKeyword_9; }
		
		//'min'
		public Keyword getMinKeyword_10() { return cMinKeyword_10; }
		
		//'mod'
		public Keyword getModKeyword_11() { return cModKeyword_11; }
		
		//'pred'
		public Keyword getPredKeyword_12() { return cPredKeyword_12; }
		
		//'prj1'
		public Keyword getPrj1Keyword_13() { return cPrj1Keyword_13; }
		
		//'prj2'
		public Keyword getPrj2Keyword_14() { return cPrj2Keyword_14; }
		
		//'ran'
		public Keyword getRanKeyword_15() { return cRanKeyword_15; }
		
		//'succ'
		public Keyword getSuccKeyword_16() { return cSuccKeyword_16; }
		
		//'union'
		public Keyword getUnionKeyword_17() { return cUnionKeyword_17; }
		
		//'ℕ1'
		public Keyword getDoubleStruckCapitalNDigitOneKeyword_18() { return cDoubleStruckCapitalNDigitOneKeyword_18; }
		
		//'ℕ'
		public Keyword getDoubleStruckCapitalNKeyword_19() { return cDoubleStruckCapitalNKeyword_19; }
		
		//'ℙ1'
		public Keyword getDoubleStruckCapitalPDigitOneKeyword_20() { return cDoubleStruckCapitalPDigitOneKeyword_20; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_21() { return cDoubleStruckCapitalPKeyword_21; }
		
		//'ℤ'
		public Keyword getDoubleStruckCapitalZKeyword_22() { return cDoubleStruckCapitalZKeyword_22; }
	}
	public class EVENTB_PREDICATE_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_PREDICATE_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cRightwardsDoubleArrowKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAmpersandKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLogicalOrKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNotSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDownTackKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUpTackKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cForAllKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cExclamationMarkKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cThereExistsKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cNumberSignKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cCommaKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cMiddleDotKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cFullStopKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cEqualsSignKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cNotEqualToKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLessThanOrEqualToKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cLessThanSignKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cGreaterThanOrEqualToKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cGreaterThanSignKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cElementOfKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cColonKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cNotAnElementOfKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cSubsetOfKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cNotASubsetOfKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cSubsetOfOrEqualToKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cNeitherASubsetOfNorEqualToKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cPartitionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		
		//EVENTB_PREDICATE_SYMBOLS:
		//	'(' | // Predicate calculus symbols
		//	')' |
		//	'⇔' |
		//	'⇒' |
		//	'∧' | '&' |
		//	'∨' |
		//	'¬' |
		//	'⊤' |
		//	'⊥' |
		//	'∀' | '!' |
		//	'∃' | '#' |
		//	',' |
		//	'·' | '.' |
		//	'=' | // Build predicates from expressions
		//	'≠' |
		//	'≤' |
		//	'<' |
		//	'≥' |
		//	'>' |
		//	'∈' | ':' | // Include this for Rodin keyboard
		//	'∉' |
		//	'⊂' |
		//	'⊄' |
		//	'⊆' |
		//	'⊈' |
		//	'partition' // This is missing from the Rodin D7 deliverable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' | // Predicate calculus symbols
		//')' |
		//'⇔' |
		//'⇒' |
		//'∧' | '&' |
		//'∨' |
		//'¬' |
		//'⊤' |
		//'⊥' |
		//'∀' | '!' |
		//'∃' | '#' |
		//',' |
		//'·' | '.' |
		//'=' | // Build predicates from expressions
		//'≠' |
		//'≤' |
		//'<' |
		//'≥' |
		//'>' |
		//'∈' | ':' | // Include this for Rodin keyboard
		//'∉' |
		//'⊂' |
		//'⊄' |
		//'⊆' |
		//'⊈' |
		//'partition'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//// Predicate calculus symbols
		//')'
		public Keyword getRightParenthesisKeyword_1() { return cRightParenthesisKeyword_1; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_2() { return cLeftRightDoubleArrowKeyword_2; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_3() { return cRightwardsDoubleArrowKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'&'
		public Keyword getAmpersandKeyword_5() { return cAmpersandKeyword_5; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_6() { return cLogicalOrKeyword_6; }
		
		//'¬'
		public Keyword getNotSignKeyword_7() { return cNotSignKeyword_7; }
		
		//'⊤'
		public Keyword getDownTackKeyword_8() { return cDownTackKeyword_8; }
		
		//'⊥'
		public Keyword getUpTackKeyword_9() { return cUpTackKeyword_9; }
		
		//'∀'
		public Keyword getForAllKeyword_10() { return cForAllKeyword_10; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_11() { return cExclamationMarkKeyword_11; }
		
		//'∃'
		public Keyword getThereExistsKeyword_12() { return cThereExistsKeyword_12; }
		
		//'#'
		public Keyword getNumberSignKeyword_13() { return cNumberSignKeyword_13; }
		
		//','
		public Keyword getCommaKeyword_14() { return cCommaKeyword_14; }
		
		//'·'
		public Keyword getMiddleDotKeyword_15() { return cMiddleDotKeyword_15; }
		
		//'.'
		public Keyword getFullStopKeyword_16() { return cFullStopKeyword_16; }
		
		//'='
		public Keyword getEqualsSignKeyword_17() { return cEqualsSignKeyword_17; }
		
		//// Build predicates from expressions
		//'≠'
		public Keyword getNotEqualToKeyword_18() { return cNotEqualToKeyword_18; }
		
		//'≤'
		public Keyword getLessThanOrEqualToKeyword_19() { return cLessThanOrEqualToKeyword_19; }
		
		//'<'
		public Keyword getLessThanSignKeyword_20() { return cLessThanSignKeyword_20; }
		
		//'≥'
		public Keyword getGreaterThanOrEqualToKeyword_21() { return cGreaterThanOrEqualToKeyword_21; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_22() { return cGreaterThanSignKeyword_22; }
		
		//'∈'
		public Keyword getElementOfKeyword_23() { return cElementOfKeyword_23; }
		
		//':'
		public Keyword getColonKeyword_24() { return cColonKeyword_24; }
		
		//// Include this for Rodin keyboard
		//'∉'
		public Keyword getNotAnElementOfKeyword_25() { return cNotAnElementOfKeyword_25; }
		
		//'⊂'
		public Keyword getSubsetOfKeyword_26() { return cSubsetOfKeyword_26; }
		
		//'⊄'
		public Keyword getNotASubsetOfKeyword_27() { return cNotASubsetOfKeyword_27; }
		
		//'⊆'
		public Keyword getSubsetOfOrEqualToKeyword_28() { return cSubsetOfOrEqualToKeyword_28; }
		
		//'⊈'
		public Keyword getNeitherASubsetOfNorEqualToKeyword_29() { return cNeitherASubsetOfNorEqualToKeyword_29; }
		
		//'partition'
		public Keyword getPartitionKeyword_30() { return cPartitionKeyword_30; }
	}
	public class EVENTB_EXPRESSION_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_EXPRESSION_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPrivateUseAreaE100Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE101Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE102Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsArrowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithTailWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cLeftCurlyBracketKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cRightCurlyBracketKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cRightwardsArrowFromBarKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cEmptySetKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cIntersectionKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cUnionKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cSetMinusKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cMultiplicationSignKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLeftSquareBracketKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cRightSquareBracketKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cPrivateUseAreaE103Keyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cRingOperatorKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cSemicolonKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cCircledTimesKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cParallelToKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cTildeOperatorKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cWhiteLeftPointingTriangleKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cZNotationDomainAntirestrictionKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cWhiteRightPointingTriangleKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cZNotationRangeAntirestrictionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cGreekSmallLetterLamdaKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Group cGroup_32 = (Group)cAlternatives.eContents().get(32);
		private final Keyword cPercentSignKeyword_32_0 = (Keyword)cGroup_32.eContents().get(0);
		private final Keyword cNAryIntersectionKeyword_32_1 = (Keyword)cGroup_32.eContents().get(1);
		private final Keyword cNAryUnionKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cDividesKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cTwoDotLeaderKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cPlusSignKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cMinusSignKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cHyphenMinusKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cAsteriskOperatorKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cAsteriskKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cDivisionSignKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cSolidusKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cCircumflexAccentKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cBackslashKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		
		//EVENTB_EXPRESSION_SYMBOLS:
		//	'↔' | // Symbols for building set of relations
		//	'' |
		//	'' |
		//	'' |
		//	'⇸' |
		//	'→' |
		//	'⤔' |
		//	'↣' |
		//	'⤀' |
		//	'↠' |
		//	'⤖' |
		//	'{' | // Symbols for manipulating sets
		//	'}' |
		//	'↦' |
		//	'∅' |
		//	'∩' |
		//	'∪' |
		//	'∖' |
		//	'×' |
		//	'[' | // Symbols for manipulating functions and relations
		//	']' |
		//	'' |
		//	'∘' |
		//	';' |
		//	'⊗' |
		//	'∥' |
		//	'∼' |
		//	'◁' |
		//	'⩤' |
		//	'▷' |
		//	'⩥' |
		//	'λ' | '%' // Symbols for quantified expressions
		//	'⋂' |
		//	'⋃' |
		//	'∣' |
		//	'‥' | // Symbols for arithmetic expressions
		//	'+' |
		//	'−' | '-' |
		//	'∗' | '*' |
		//	'÷' | '/' |
		//	'^' |
		//	'\\' // Allowed for LaTeX combos
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'↔' | // Symbols for building set of relations
		//'' |
		//'' |
		//'' |
		//'⇸' |
		//'→' |
		//'⤔' |
		//'↣' |
		//'⤀' |
		//'↠' |
		//'⤖' |
		//'{' | // Symbols for manipulating sets
		//'}' |
		//'↦' |
		//'∅' |
		//'∩' |
		//'∪' |
		//'∖' |
		//'×' |
		//'[' | // Symbols for manipulating functions and relations
		//']' |
		//'' |
		//'∘' |
		//';' |
		//'⊗' |
		//'∥' |
		//'∼' |
		//'◁' |
		//'⩤' |
		//'▷' |
		//'⩥' |
		//'λ' | '%' // Symbols for quantified expressions
		//'⋂' |
		//'⋃' |
		//'∣' |
		//'‥' | // Symbols for arithmetic expressions
		//'+' |
		//'−' | '-' |
		//'∗' | '*' |
		//'÷' | '/' |
		//'^' |
		//'\\'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_0() { return cLeftRightArrowKeyword_0; }
		
		//// Symbols for building set of relations
		//''
		public Keyword getPrivateUseAreaE100Keyword_1() { return cPrivateUseAreaE100Keyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE101Keyword_2() { return cPrivateUseAreaE101Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_3() { return cPrivateUseAreaE102Keyword_3; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_4() { return cRightwardsArrowWithVerticalStrokeKeyword_4; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_5() { return cRightwardsArrowKeyword_5; }
		
		//'⤔'
		public Keyword getRightwardsArrowWithTailWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithTailWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_10() { return cRightwardsTwoHeadedArrowWithTailKeyword_10; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_11() { return cLeftCurlyBracketKeyword_11; }
		
		//// Symbols for manipulating sets
		//'}'
		public Keyword getRightCurlyBracketKeyword_12() { return cRightCurlyBracketKeyword_12; }
		
		//'↦'
		public Keyword getRightwardsArrowFromBarKeyword_13() { return cRightwardsArrowFromBarKeyword_13; }
		
		//'∅'
		public Keyword getEmptySetKeyword_14() { return cEmptySetKeyword_14; }
		
		//'∩'
		public Keyword getIntersectionKeyword_15() { return cIntersectionKeyword_15; }
		
		//'∪'
		public Keyword getUnionKeyword_16() { return cUnionKeyword_16; }
		
		//'∖'
		public Keyword getSetMinusKeyword_17() { return cSetMinusKeyword_17; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_18() { return cMultiplicationSignKeyword_18; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_19() { return cLeftSquareBracketKeyword_19; }
		
		//// Symbols for manipulating functions and relations
		//']'
		public Keyword getRightSquareBracketKeyword_20() { return cRightSquareBracketKeyword_20; }
		
		//''
		public Keyword getPrivateUseAreaE103Keyword_21() { return cPrivateUseAreaE103Keyword_21; }
		
		//'∘'
		public Keyword getRingOperatorKeyword_22() { return cRingOperatorKeyword_22; }
		
		//';'
		public Keyword getSemicolonKeyword_23() { return cSemicolonKeyword_23; }
		
		//'⊗'
		public Keyword getCircledTimesKeyword_24() { return cCircledTimesKeyword_24; }
		
		//'∥'
		public Keyword getParallelToKeyword_25() { return cParallelToKeyword_25; }
		
		//'∼'
		public Keyword getTildeOperatorKeyword_26() { return cTildeOperatorKeyword_26; }
		
		//'◁'
		public Keyword getWhiteLeftPointingTriangleKeyword_27() { return cWhiteLeftPointingTriangleKeyword_27; }
		
		//'⩤'
		public Keyword getZNotationDomainAntirestrictionKeyword_28() { return cZNotationDomainAntirestrictionKeyword_28; }
		
		//'▷'
		public Keyword getWhiteRightPointingTriangleKeyword_29() { return cWhiteRightPointingTriangleKeyword_29; }
		
		//'⩥'
		public Keyword getZNotationRangeAntirestrictionKeyword_30() { return cZNotationRangeAntirestrictionKeyword_30; }
		
		//'λ'
		public Keyword getGreekSmallLetterLamdaKeyword_31() { return cGreekSmallLetterLamdaKeyword_31; }
		
		//'%' // Symbols for quantified expressions
		//'⋂'
		public Group getGroup_32() { return cGroup_32; }
		
		//'%'
		public Keyword getPercentSignKeyword_32_0() { return cPercentSignKeyword_32_0; }
		
		//// Symbols for quantified expressions
		//'⋂'
		public Keyword getNAryIntersectionKeyword_32_1() { return cNAryIntersectionKeyword_32_1; }
		
		//'⋃'
		public Keyword getNAryUnionKeyword_33() { return cNAryUnionKeyword_33; }
		
		//'∣'
		public Keyword getDividesKeyword_34() { return cDividesKeyword_34; }
		
		//'‥'
		public Keyword getTwoDotLeaderKeyword_35() { return cTwoDotLeaderKeyword_35; }
		
		//// Symbols for arithmetic expressions
		//'+'
		public Keyword getPlusSignKeyword_36() { return cPlusSignKeyword_36; }
		
		//'−'
		public Keyword getMinusSignKeyword_37() { return cMinusSignKeyword_37; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_38() { return cHyphenMinusKeyword_38; }
		
		//'∗'
		public Keyword getAsteriskOperatorKeyword_39() { return cAsteriskOperatorKeyword_39; }
		
		//'*'
		public Keyword getAsteriskKeyword_40() { return cAsteriskKeyword_40; }
		
		//'÷'
		public Keyword getDivisionSignKeyword_41() { return cDivisionSignKeyword_41; }
		
		//'/'
		public Keyword getSolidusKeyword_42() { return cSolidusKeyword_42; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_43() { return cCircumflexAccentKeyword_43; }
		
		//'\\'
		public Keyword getBackslashKeyword_44() { return cBackslashKeyword_44; }
	}
	public class XRecordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XRecord");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRecordAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRecordKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cInheritsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cSubsetsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cSubsetsRecordCrossReference_3_1_0 = (CrossReference)cSubsetsAssignment_3_1.eContents().get(0);
		private final RuleCall cSubsetsRecordIDTerminalRuleCall_3_1_0_1 = (RuleCall)cSubsetsRecordCrossReference_3_1_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cFieldsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cFieldsFieldParserRuleCall_4_0_0 = (RuleCall)cFieldsAssignment_4_0.eContents().get(0);
		private final Assignment cFieldsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_4_1_0 = (RuleCall)cFieldsAssignment_4_1.eContents().get(0);
		
		///*
		// * support for records
		// */
		//XRecord erecords::Record:
		//	{erecords::Record}
		//	'record' name=ID ('inherits' subsets=[erecords::Record])? (fields+=Field fields+=Field*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{erecords::Record}
		//'record' name=ID ('inherits' subsets=[erecords::Record])? (fields+=Field fields+=Field*)?
		public Group getGroup() { return cGroup; }
		
		//{erecords::Record}
		public Action getRecordAction_0() { return cRecordAction_0; }
		
		//'record'
		public Keyword getRecordKeyword_1() { return cRecordKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//('inherits' subsets=[erecords::Record])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'inherits'
		public Keyword getInheritsKeyword_3_0() { return cInheritsKeyword_3_0; }
		
		//subsets=[erecords::Record]
		public Assignment getSubsetsAssignment_3_1() { return cSubsetsAssignment_3_1; }
		
		//[erecords::Record]
		public CrossReference getSubsetsRecordCrossReference_3_1_0() { return cSubsetsRecordCrossReference_3_1_0; }
		
		//ID
		public RuleCall getSubsetsRecordIDTerminalRuleCall_3_1_0_1() { return cSubsetsRecordIDTerminalRuleCall_3_1_0_1; }
		
		//(fields+=Field fields+=Field*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_4_0() { return cFieldsAssignment_4_0; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_4_0_0() { return cFieldsFieldParserRuleCall_4_0_0; }
		
		//fields+=Field*
		public Assignment getFieldsAssignment_4_1() { return cFieldsAssignment_4_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_4_1_0() { return cFieldsFieldParserRuleCall_4_1_0; }
	}
	public class FieldTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.FieldType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FieldType:
		//	ID | EVENTB_IDENTIFIER_KEYWORD;
		@Override public ParserRule getRule() { return rule; }
		
		//ID | EVENTB_IDENTIFIER_KEYWORD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//EVENTB_IDENTIFIER_KEYWORD
		public RuleCall getEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1() { return cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMultiplicityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMultiplicityMultiplicityEnumRuleCall_2_0 = (RuleCall)cMultiplicityAssignment_2.eContents().get(0);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeFieldTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//Field erecords::Field:
		//	name=ID ':' multiplicity=Multiplicity?
		//	type=FieldType;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' multiplicity=Multiplicity?
		//type=FieldType
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//multiplicity=Multiplicity?
		public Assignment getMultiplicityAssignment_2() { return cMultiplicityAssignment_2; }
		
		//Multiplicity
		public RuleCall getMultiplicityMultiplicityEnumRuleCall_2_0() { return cMultiplicityMultiplicityEnumRuleCall_2_0; }
		
		//type=FieldType
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//FieldType
		public RuleCall getTypeFieldTypeParserRuleCall_3_0() { return cTypeFieldTypeParserRuleCall_3_0; }
	}
	
	public class MultiplicityElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.Multiplicity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cONEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cONEOneKeyword_0_0 = (Keyword)cONEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMANYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMANYManyKeyword_1_0 = (Keyword)cMANYEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOPTIONALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOPTIONALOptKeyword_2_0 = (Keyword)cOPTIONALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Multiplicity returns erecords::Multiplicity:
		//	ONE='one' | MANY='many' | OPTIONAL='opt';
		public EnumRule getRule() { return rule; }
		
		//ONE='one' | MANY='many' | OPTIONAL='opt'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ONE='one'
		public EnumLiteralDeclaration getONEEnumLiteralDeclaration_0() { return cONEEnumLiteralDeclaration_0; }
		
		//'one'
		public Keyword getONEOneKeyword_0_0() { return cONEOneKeyword_0_0; }
		
		//MANY='many'
		public EnumLiteralDeclaration getMANYEnumLiteralDeclaration_1() { return cMANYEnumLiteralDeclaration_1; }
		
		//'many'
		public Keyword getMANYManyKeyword_1_0() { return cMANYManyKeyword_1_0; }
		
		//OPTIONAL='opt'
		public EnumLiteralDeclaration getOPTIONALEnumLiteralDeclaration_2() { return cOPTIONALEnumLiteralDeclaration_2; }
		
		//'opt'
		public Keyword getOPTIONALOptKeyword_2_0() { return cOPTIONALOptKeyword_2_0; }
	}
	
	private final XContextElements pXContext;
	private final QualifiedNameElements pQualifiedName;
	private final XCarrierSetElements pXCarrierSet;
	private final XConstantElements pXConstant;
	private final XTypedConstantElements pXTypedConstant;
	private final XSingleAxiomElements pXSingleAxiom;
	private final TerminalRule tXLABEL;
	private final XFormulaElements pXFormula;
	private final XTypeElements pXType;
	private final XTYPEOPERATORElements pXTYPEOPERATOR;
	private final XTypePrimitiveElements pXTypePrimitive;
	private final EVENTB_IDENTIFIER_KEYWORDElements pEVENTB_IDENTIFIER_KEYWORD;
	private final EVENTB_PREDICATE_SYMBOLSElements pEVENTB_PREDICATE_SYMBOLS;
	private final EVENTB_EXPRESSION_SYMBOLSElements pEVENTB_EXPRESSION_SYMBOLS;
	private final TerminalRule tID;
	private final TerminalRule tUNTRANSLATED_TOKEN;
	private final TerminalRule tSTRING;
	private final XRecordElements pXRecord;
	private final FieldTypeElements pFieldType;
	private final FieldElements pField;
	private final MultiplicityElements eMultiplicity;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public XContextGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pXContext = new XContextElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pXCarrierSet = new XCarrierSetElements();
		this.pXConstant = new XConstantElements();
		this.pXTypedConstant = new XTypedConstantElements();
		this.pXSingleAxiom = new XSingleAxiomElements();
		this.tXLABEL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XLABEL");
		this.pXFormula = new XFormulaElements();
		this.pXType = new XTypeElements();
		this.pXTYPEOPERATOR = new XTYPEOPERATORElements();
		this.pXTypePrimitive = new XTypePrimitiveElements();
		this.pEVENTB_IDENTIFIER_KEYWORD = new EVENTB_IDENTIFIER_KEYWORDElements();
		this.pEVENTB_PREDICATE_SYMBOLS = new EVENTB_PREDICATE_SYMBOLSElements();
		this.pEVENTB_EXPRESSION_SYMBOLS = new EVENTB_EXPRESSION_SYMBOLSElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.ID");
		this.tUNTRANSLATED_TOKEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.UNTRANSLATED_TOKEN");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.STRING");
		this.pXRecord = new XRecordElements();
		this.pFieldType = new FieldTypeElements();
		this.pField = new FieldElements();
		this.eMultiplicity = new MultiplicityElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.xeventb.xcontext.XContext".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//XContext econtext::Context:
	//	{econtext::Context} comment=STRING?
	//	'context' name=ID ('extends' extends+=[econtext::Context|QualifiedName]+)? ('sets' orderedChildren+=XCarrierSet+ |
	//	'constants' orderedChildren+=XConstant+ | 'constant' orderedChildren+=XTypedConstant | orderedChildren+=XRecord |
	//	orderedChildren+=XSingleAxiom)*
	//	'end';
	public XContextElements getXContextAccess() {
		return pXContext;
	}
	
	public ParserRule getXContextRule() {
		return getXContextAccess().getRule();
	}
	
	//QualifiedName:
	//	ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//XCarrierSet econtext::CarrierSet:
	//	{econtext::CarrierSet} comment=STRING?
	//	name=ID;
	public XCarrierSetElements getXCarrierSetAccess() {
		return pXCarrierSet;
	}
	
	public ParserRule getXCarrierSetRule() {
		return getXCarrierSetAccess().getRule();
	}
	
	//XConstant econtext::Constant:
	//	{econtext::Constant} comment=STRING?
	//	name=ID;
	public XConstantElements getXConstantAccess() {
		return pXConstant;
	}
	
	public ParserRule getXConstantRule() {
		return getXConstantAccess().getRule();
	}
	
	//XTypedConstant eventbcoreex::TypedConstant:
	//	{eventbcoreex::TypedConstant} comment=STRING?
	//	name=ID (':' type=XType)? ('=' value=XFormula)?;
	public XTypedConstantElements getXTypedConstantAccess() {
		return pXTypedConstant;
	}
	
	public ParserRule getXTypedConstantRule() {
		return getXTypedConstantAccess().getRule();
	}
	
	//XSingleAxiom econtext::Axiom:
	//	{econtext::Axiom} comment=STRING? (theorem?='theorem' | 'axiom') name=XLABEL predicate=XFormula;
	public XSingleAxiomElements getXSingleAxiomAccess() {
		return pXSingleAxiom;
	}
	
	public ParserRule getXSingleAxiomRule() {
		return getXSingleAxiomAccess().getRule();
	}
	
	//terminal XLABEL:
	//	'@' !':'+ ':';
	public TerminalRule getXLABELRule() {
		return tXLABEL;
	}
	
	//XFormula:
	//	(EVENTB_IDENTIFIER_KEYWORD | EVENTB_PREDICATE_SYMBOLS | EVENTB_EXPRESSION_SYMBOLS | ID | INT | UNTRANSLATED_TOKEN)+;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//XType:
	//	XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*;
	public XTypeElements getXTypeAccess() {
		return pXType;
	}
	
	public ParserRule getXTypeRule() {
		return getXTypeAccess().getRule();
	}
	
	//XTYPEOPERATOR:
	//	'↔' | // Symbols for building set of relations
	//	'' |
	//	'' |
	//	'' |
	//	'⇸' |
	//	'→' |
	//	'⤔' |
	//	'↣' |
	//	'⤀' |
	//	'↠' |
	//	'⤖' |
	//	'×';
	public XTYPEOPERATORElements getXTYPEOPERATORAccess() {
		return pXTYPEOPERATOR;
	}
	
	public ParserRule getXTYPEOPERATORRule() {
		return getXTYPEOPERATORAccess().getRule();
	}
	
	//XTypePrimitive:
	//	ID |
	//	'BOOL' |
	//	'ℕ1' |
	//	'ℕ' |
	//	'ℤ' |
	//	'(' XType ')' |
	//	'ℙ' '(' XType ')' |
	//	'ℙ1' '(' XType ')';
	public XTypePrimitiveElements getXTypePrimitiveAccess() {
		return pXTypePrimitive;
	}
	
	public ParserRule getXTypePrimitiveRule() {
		return getXTypePrimitiveAccess().getRule();
	}
	
	//// IMPORTANT: Do not make these terminal as it can cause problem with the XType
	//EVENTB_IDENTIFIER_KEYWORD:
	//	'BOOL' |
	//	'FALSE' |
	//	'TRUE' |
	//	'bool' |
	//	'card' |
	//	'dom' |
	//	'finite' |
	//	'id' |
	//	'inter' |
	//	'max' |
	//	'min' |
	//	'mod' |
	//	'pred' |
	//	'prj1' |
	//	'prj2' |
	//	'ran' |
	//	'succ' |
	//	'union' |
	//	'ℕ1' |
	//	'ℕ' |
	//	'ℙ1' |
	//	'ℙ' |
	//	'ℤ';
	public EVENTB_IDENTIFIER_KEYWORDElements getEVENTB_IDENTIFIER_KEYWORDAccess() {
		return pEVENTB_IDENTIFIER_KEYWORD;
	}
	
	public ParserRule getEVENTB_IDENTIFIER_KEYWORDRule() {
		return getEVENTB_IDENTIFIER_KEYWORDAccess().getRule();
	}
	
	//EVENTB_PREDICATE_SYMBOLS:
	//	'(' | // Predicate calculus symbols
	//	')' |
	//	'⇔' |
	//	'⇒' |
	//	'∧' | '&' |
	//	'∨' |
	//	'¬' |
	//	'⊤' |
	//	'⊥' |
	//	'∀' | '!' |
	//	'∃' | '#' |
	//	',' |
	//	'·' | '.' |
	//	'=' | // Build predicates from expressions
	//	'≠' |
	//	'≤' |
	//	'<' |
	//	'≥' |
	//	'>' |
	//	'∈' | ':' | // Include this for Rodin keyboard
	//	'∉' |
	//	'⊂' |
	//	'⊄' |
	//	'⊆' |
	//	'⊈' |
	//	'partition' // This is missing from the Rodin D7 deliverable
	//;
	public EVENTB_PREDICATE_SYMBOLSElements getEVENTB_PREDICATE_SYMBOLSAccess() {
		return pEVENTB_PREDICATE_SYMBOLS;
	}
	
	public ParserRule getEVENTB_PREDICATE_SYMBOLSRule() {
		return getEVENTB_PREDICATE_SYMBOLSAccess().getRule();
	}
	
	//EVENTB_EXPRESSION_SYMBOLS:
	//	'↔' | // Symbols for building set of relations
	//	'' |
	//	'' |
	//	'' |
	//	'⇸' |
	//	'→' |
	//	'⤔' |
	//	'↣' |
	//	'⤀' |
	//	'↠' |
	//	'⤖' |
	//	'{' | // Symbols for manipulating sets
	//	'}' |
	//	'↦' |
	//	'∅' |
	//	'∩' |
	//	'∪' |
	//	'∖' |
	//	'×' |
	//	'[' | // Symbols for manipulating functions and relations
	//	']' |
	//	'' |
	//	'∘' |
	//	';' |
	//	'⊗' |
	//	'∥' |
	//	'∼' |
	//	'◁' |
	//	'⩤' |
	//	'▷' |
	//	'⩥' |
	//	'λ' | '%' // Symbols for quantified expressions
	//	'⋂' |
	//	'⋃' |
	//	'∣' |
	//	'‥' | // Symbols for arithmetic expressions
	//	'+' |
	//	'−' | '-' |
	//	'∗' | '*' |
	//	'÷' | '/' |
	//	'^' |
	//	'\\' // Allowed for LaTeX combos
	//;
	public EVENTB_EXPRESSION_SYMBOLSElements getEVENTB_EXPRESSION_SYMBOLSAccess() {
		return pEVENTB_EXPRESSION_SYMBOLS;
	}
	
	public ParserRule getEVENTB_EXPRESSION_SYMBOLSRule() {
		return getEVENTB_EXPRESSION_SYMBOLSAccess().getRule();
	}
	
	//@Override
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ') ('a'..'z' | 'A'..'Z' | '_' | 'i'..'ￜ' | '0'..'9' | "'")*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal UNTRANSLATED_TOKEN:
	//	'!' | '#' | '%' | '&' | '*' | '-' | ':' | '|' | '\\' | ',' | '~' | '/' | '.'+;
	public TerminalRule getUNTRANSLATED_TOKENRule() {
		return tUNTRANSLATED_TOKEN;
	}
	
	//@Override
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	///*
	// * support for records
	// */
	//XRecord erecords::Record:
	//	{erecords::Record}
	//	'record' name=ID ('inherits' subsets=[erecords::Record])? (fields+=Field fields+=Field*)?;
	public XRecordElements getXRecordAccess() {
		return pXRecord;
	}
	
	public ParserRule getXRecordRule() {
		return getXRecordAccess().getRule();
	}
	
	//FieldType:
	//	ID | EVENTB_IDENTIFIER_KEYWORD;
	public FieldTypeElements getFieldTypeAccess() {
		return pFieldType;
	}
	
	public ParserRule getFieldTypeRule() {
		return getFieldTypeAccess().getRule();
	}
	
	//Field erecords::Field:
	//	name=ID ':' multiplicity=Multiplicity?
	//	type=FieldType;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//enum Multiplicity returns erecords::Multiplicity:
	//	ONE='one' | MANY='many' | OPTIONAL='opt';
	public MultiplicityElements getMultiplicityAccess() {
		return eMultiplicity;
	}
	
	public EnumRule getMultiplicityRule() {
		return getMultiplicityAccess().getRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
