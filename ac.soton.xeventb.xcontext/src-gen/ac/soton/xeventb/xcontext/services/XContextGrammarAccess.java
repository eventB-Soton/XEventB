/*
 * generated by Xtext 2.25.0
 */
package ac.soton.xeventb.xcontext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class XContextGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class XContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContextAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Keyword cContextKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Keyword cExtendsKeyword_4_0_0 = (Keyword)cGroup_4_0.eContents().get(0);
		private final Assignment cExtendsAssignment_4_0_1 = (Assignment)cGroup_4_0.eContents().get(1);
		private final CrossReference cExtendsContextCrossReference_4_0_1_0 = (CrossReference)cExtendsAssignment_4_0_1.eContents().get(0);
		private final RuleCall cExtendsContextQualifiedNameParserRuleCall_4_0_1_0_1 = (RuleCall)cExtendsContextCrossReference_4_0_1_0.eContents().get(1);
		private final Group cGroup_4_1 = (Group)cAlternatives_4.eContents().get(1);
		private final Alternatives cAlternatives_4_1_0 = (Alternatives)cGroup_4_1.eContents().get(0);
		private final Keyword cExtendKeyword_4_1_0_0 = (Keyword)cAlternatives_4_1_0.eContents().get(0);
		private final Keyword cExtKeyword_4_1_0_1 = (Keyword)cAlternatives_4_1_0.eContents().get(1);
		private final Assignment cExtendsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final CrossReference cExtendsContextCrossReference_4_1_1_0 = (CrossReference)cExtendsAssignment_4_1_1.eContents().get(0);
		private final RuleCall cExtendsContextQualifiedNameParserRuleCall_4_1_1_0_1 = (RuleCall)cExtendsContextCrossReference_4_1_1_0.eContents().get(1);
		private final Group cGroup_4_2 = (Group)cAlternatives_4.eContents().get(2);
		private final Keyword cSetsKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cOrderedChildrenXCarrierSetParserRuleCall_4_2_1_0 = (RuleCall)cOrderedChildrenAssignment_4_2_1.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_3 = (Assignment)cAlternatives_4.eContents().get(3);
		private final RuleCall cOrderedChildrenXIndividualCarrierSetParserRuleCall_4_3_0 = (RuleCall)cOrderedChildrenAssignment_4_3.eContents().get(0);
		private final Group cGroup_4_4 = (Group)cAlternatives_4.eContents().get(4);
		private final Keyword cConstantsKeyword_4_4_0 = (Keyword)cGroup_4_4.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_4_1 = (Assignment)cGroup_4_4.eContents().get(1);
		private final RuleCall cOrderedChildrenXConstantParserRuleCall_4_4_1_0 = (RuleCall)cOrderedChildrenAssignment_4_4_1.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_5 = (Assignment)cAlternatives_4.eContents().get(5);
		private final RuleCall cOrderedChildrenXIndividualConstantParserRuleCall_4_5_0 = (RuleCall)cOrderedChildrenAssignment_4_5.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_6 = (Assignment)cAlternatives_4.eContents().get(6);
		private final RuleCall cOrderedChildrenXRecordParserRuleCall_4_6_0 = (RuleCall)cOrderedChildrenAssignment_4_6.eContents().get(0);
		private final Group cGroup_4_7 = (Group)cAlternatives_4.eContents().get(7);
		private final Keyword cAxiomsKeyword_4_7_0 = (Keyword)cGroup_4_7.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_7_1 = (Assignment)cGroup_4_7.eContents().get(1);
		private final RuleCall cOrderedChildrenXAxiomParserRuleCall_4_7_1_0 = (RuleCall)cOrderedChildrenAssignment_4_7_1.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_8 = (Assignment)cAlternatives_4.eContents().get(8);
		private final RuleCall cOrderedChildrenXIndividualAxiomParserRuleCall_4_8_0 = (RuleCall)cOrderedChildrenAssignment_4_8.eContents().get(0);
		private final Assignment cOrderedChildrenAssignment_4_9 = (Assignment)cAlternatives_4.eContents().get(9);
		private final RuleCall cOrderedChildrenXIndividualTheoremParserRuleCall_4_9_0 = (RuleCall)cOrderedChildrenAssignment_4_9.eContents().get(0);
		
		//XContext returns econtext::Context:
		//    {econtext::Context}
		//    (comment = STRING)?
		//    'context' name=ID
		//    (
		//         // Multiple-extend clause
		//        ('extends' extends+=[econtext::Context |QualifiedName]+) |
		//        // Individual-extend clause
		//        (('extend' | 'ext') extends+=[econtext::Context |QualifiedName]) |
		//        // Multiple-(carrier)set clause
		//        ('sets' orderedChildren+=XCarrierSet+) |
		//        // Individual-(carrier)set clause
		//        (orderedChildren+=XIndividualCarrierSet) |
		//        // Multiple-constant clause
		//        ('constants' orderedChildren+=XConstant+) |
		//        // Individual-constant clause
		//        (orderedChildren+=XIndividualConstant) |
		//        (orderedChildren += XRecord) |
		//        /*
		//         * Multiple-axiom clause
		//         * To avoid ambiguity, theorems is no longer allowed to be a part of "axioms",
		//         * instead, keyword "theorem" will signify an individual theorem.
		//         */
		//        ('axioms' orderedChildren+=XAxiom+) |
		//        // Individual-axiom clause
		//        (orderedChildren+=XIndividualAxiom) |
		//        // Individual-theorem clause
		//        (orderedChildren+=XIndividualTheorem)
		//    )*
		//    // Since CamilleX 3.0, we do not have the final 'end' keyword
		////    'end'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Context}
		//(comment = STRING)?
		//'context' name=ID
		//(
		//     // Multiple-extend clause
		//    ('extends' extends+=[econtext::Context |QualifiedName]+) |
		//    // Individual-extend clause
		//    (('extend' | 'ext') extends+=[econtext::Context |QualifiedName]) |
		//    // Multiple-(carrier)set clause
		//    ('sets' orderedChildren+=XCarrierSet+) |
		//    // Individual-(carrier)set clause
		//    (orderedChildren+=XIndividualCarrierSet) |
		//    // Multiple-constant clause
		//    ('constants' orderedChildren+=XConstant+) |
		//    // Individual-constant clause
		//    (orderedChildren+=XIndividualConstant) |
		//    (orderedChildren += XRecord) |
		//    /*
		//     * Multiple-axiom clause
		//     * To avoid ambiguity, theorems is no longer allowed to be a part of "axioms",
		//     * instead, keyword "theorem" will signify an individual theorem.
		//     */
		//    ('axioms' orderedChildren+=XAxiom+) |
		//    // Individual-axiom clause
		//    (orderedChildren+=XIndividualAxiom) |
		//    // Individual-theorem clause
		//    (orderedChildren+=XIndividualTheorem)
		//)*
		public Group getGroup() { return cGroup; }
		
		//{econtext::Context}
		public Action getContextAction_0() { return cContextAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//'context'
		public Keyword getContextKeyword_2() { return cContextKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//(
		//     // Multiple-extend clause
		//    ('extends' extends+=[econtext::Context |QualifiedName]+) |
		//    // Individual-extend clause
		//    (('extend' | 'ext') extends+=[econtext::Context |QualifiedName]) |
		//    // Multiple-(carrier)set clause
		//    ('sets' orderedChildren+=XCarrierSet+) |
		//    // Individual-(carrier)set clause
		//    (orderedChildren+=XIndividualCarrierSet) |
		//    // Multiple-constant clause
		//    ('constants' orderedChildren+=XConstant+) |
		//    // Individual-constant clause
		//    (orderedChildren+=XIndividualConstant) |
		//    (orderedChildren += XRecord) |
		//    /*
		//     * Multiple-axiom clause
		//     * To avoid ambiguity, theorems is no longer allowed to be a part of "axioms",
		//     * instead, keyword "theorem" will signify an individual theorem.
		//     */
		//    ('axioms' orderedChildren+=XAxiom+) |
		//    // Individual-axiom clause
		//    (orderedChildren+=XIndividualAxiom) |
		//    // Individual-theorem clause
		//    (orderedChildren+=XIndividualTheorem)
		//)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		// // Multiple-extend clause
		//('extends' extends+=[econtext::Context |QualifiedName]+)
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//'extends'
		public Keyword getExtendsKeyword_4_0_0() { return cExtendsKeyword_4_0_0; }
		
		//extends+=[econtext::Context |QualifiedName]+
		public Assignment getExtendsAssignment_4_0_1() { return cExtendsAssignment_4_0_1; }
		
		//[econtext::Context |QualifiedName]
		public CrossReference getExtendsContextCrossReference_4_0_1_0() { return cExtendsContextCrossReference_4_0_1_0; }
		
		//QualifiedName
		public RuleCall getExtendsContextQualifiedNameParserRuleCall_4_0_1_0_1() { return cExtendsContextQualifiedNameParserRuleCall_4_0_1_0_1; }
		
		//// Individual-extend clause
		//(('extend' | 'ext') extends+=[econtext::Context |QualifiedName])
		public Group getGroup_4_1() { return cGroup_4_1; }
		
		//('extend' | 'ext')
		public Alternatives getAlternatives_4_1_0() { return cAlternatives_4_1_0; }
		
		//'extend'
		public Keyword getExtendKeyword_4_1_0_0() { return cExtendKeyword_4_1_0_0; }
		
		//'ext'
		public Keyword getExtKeyword_4_1_0_1() { return cExtKeyword_4_1_0_1; }
		
		//extends+=[econtext::Context |QualifiedName]
		public Assignment getExtendsAssignment_4_1_1() { return cExtendsAssignment_4_1_1; }
		
		//[econtext::Context |QualifiedName]
		public CrossReference getExtendsContextCrossReference_4_1_1_0() { return cExtendsContextCrossReference_4_1_1_0; }
		
		//QualifiedName
		public RuleCall getExtendsContextQualifiedNameParserRuleCall_4_1_1_0_1() { return cExtendsContextQualifiedNameParserRuleCall_4_1_1_0_1; }
		
		//// Multiple-(carrier)set clause
		//('sets' orderedChildren+=XCarrierSet+)
		public Group getGroup_4_2() { return cGroup_4_2; }
		
		//'sets'
		public Keyword getSetsKeyword_4_2_0() { return cSetsKeyword_4_2_0; }
		
		//orderedChildren+=XCarrierSet+
		public Assignment getOrderedChildrenAssignment_4_2_1() { return cOrderedChildrenAssignment_4_2_1; }
		
		//XCarrierSet
		public RuleCall getOrderedChildrenXCarrierSetParserRuleCall_4_2_1_0() { return cOrderedChildrenXCarrierSetParserRuleCall_4_2_1_0; }
		
		//// Individual-(carrier)set clause
		//(orderedChildren+=XIndividualCarrierSet)
		public Assignment getOrderedChildrenAssignment_4_3() { return cOrderedChildrenAssignment_4_3; }
		
		//XIndividualCarrierSet
		public RuleCall getOrderedChildrenXIndividualCarrierSetParserRuleCall_4_3_0() { return cOrderedChildrenXIndividualCarrierSetParserRuleCall_4_3_0; }
		
		//// Multiple-constant clause
		//('constants' orderedChildren+=XConstant+)
		public Group getGroup_4_4() { return cGroup_4_4; }
		
		//'constants'
		public Keyword getConstantsKeyword_4_4_0() { return cConstantsKeyword_4_4_0; }
		
		//orderedChildren+=XConstant+
		public Assignment getOrderedChildrenAssignment_4_4_1() { return cOrderedChildrenAssignment_4_4_1; }
		
		//XConstant
		public RuleCall getOrderedChildrenXConstantParserRuleCall_4_4_1_0() { return cOrderedChildrenXConstantParserRuleCall_4_4_1_0; }
		
		//// Individual-constant clause
		//(orderedChildren+=XIndividualConstant)
		public Assignment getOrderedChildrenAssignment_4_5() { return cOrderedChildrenAssignment_4_5; }
		
		//XIndividualConstant
		public RuleCall getOrderedChildrenXIndividualConstantParserRuleCall_4_5_0() { return cOrderedChildrenXIndividualConstantParserRuleCall_4_5_0; }
		
		//(orderedChildren += XRecord)
		public Assignment getOrderedChildrenAssignment_4_6() { return cOrderedChildrenAssignment_4_6; }
		
		//XRecord
		public RuleCall getOrderedChildrenXRecordParserRuleCall_4_6_0() { return cOrderedChildrenXRecordParserRuleCall_4_6_0; }
		
		///*
		// * Multiple-axiom clause
		// * To avoid ambiguity, theorems is no longer allowed to be a part of "axioms",
		// * instead, keyword "theorem" will signify an individual theorem.
		// */
		//('axioms' orderedChildren+=XAxiom+)
		public Group getGroup_4_7() { return cGroup_4_7; }
		
		//'axioms'
		public Keyword getAxiomsKeyword_4_7_0() { return cAxiomsKeyword_4_7_0; }
		
		//orderedChildren+=XAxiom+
		public Assignment getOrderedChildrenAssignment_4_7_1() { return cOrderedChildrenAssignment_4_7_1; }
		
		//XAxiom
		public RuleCall getOrderedChildrenXAxiomParserRuleCall_4_7_1_0() { return cOrderedChildrenXAxiomParserRuleCall_4_7_1_0; }
		
		//// Individual-axiom clause
		//(orderedChildren+=XIndividualAxiom)
		public Assignment getOrderedChildrenAssignment_4_8() { return cOrderedChildrenAssignment_4_8; }
		
		//XIndividualAxiom
		public RuleCall getOrderedChildrenXIndividualAxiomParserRuleCall_4_8_0() { return cOrderedChildrenXIndividualAxiomParserRuleCall_4_8_0; }
		
		//// Individual-theorem clause
		//(orderedChildren+=XIndividualTheorem)
		public Assignment getOrderedChildrenAssignment_4_9() { return cOrderedChildrenAssignment_4_9; }
		
		//XIndividualTheorem
		public RuleCall getOrderedChildrenXIndividualTheoremParserRuleCall_4_9_0() { return cOrderedChildrenXIndividualTheoremParserRuleCall_4_9_0; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//   ID ('.' ID)*
		// ;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class XCarrierSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XCarrierSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCarrierSetAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//XCarrierSet returns econtext::CarrierSet:
		//    {econtext::CarrierSet}
		//    (comment = STRING)?
		//    name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::CarrierSet}
		//(comment = STRING)?
		//name=ID
		public Group getGroup() { return cGroup; }
		
		//{econtext::CarrierSet}
		public Action getCarrierSetAction_0() { return cCarrierSetAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class XIndividualCarrierSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XIndividualCarrierSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCarrierSetAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Keyword cSetKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		
		//XIndividualCarrierSet returns econtext::CarrierSet:
		//    {econtext::CarrierSet}
		//    (comment = STRING)?
		//    'set'
		//    name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::CarrierSet}
		//(comment = STRING)?
		//'set'
		//name=ID
		public Group getGroup() { return cGroup; }
		
		//{econtext::CarrierSet}
		public Action getCarrierSetAction_0() { return cCarrierSetAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//'set'
		public Keyword getSetKeyword_2() { return cSetKeyword_2; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
	}
	public class XConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//XConstant returns econtext::Constant:
		//    {econtext::Constant}
		//    (comment = STRING)?
		//    name=ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Constant}
		//(comment = STRING)?
		//name=ID
		public Group getGroup() { return cGroup; }
		
		//{econtext::Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class XIndividualConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XIndividualConstant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTypedConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cConstantKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cCstKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cTypeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cTypeXTypeParserRuleCall_4_1_0 = (RuleCall)cTypeAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cEqualsSignKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cValueAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cValueXFormulaParserRuleCall_5_1_0 = (RuleCall)cValueAssignment_5_1.eContents().get(0);
		
		//XIndividualConstant returns eventbcoreex::TypedConstant:
		//    {eventbcoreex::TypedConstant}
		//    (comment = STRING)?
		//    ('constant' | 'cst')
		//    name=ID (':' type=XType)? ('=' value=XFormula)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{eventbcoreex::TypedConstant}
		//(comment = STRING)?
		//('constant' | 'cst')
		//name=ID (':' type=XType)? ('=' value=XFormula)?
		public Group getGroup() { return cGroup; }
		
		//{eventbcoreex::TypedConstant}
		public Action getTypedConstantAction_0() { return cTypedConstantAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//('constant' | 'cst')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'constant'
		public Keyword getConstantKeyword_2_0() { return cConstantKeyword_2_0; }
		
		//'cst'
		public Keyword getCstKeyword_2_1() { return cCstKeyword_2_1; }
		
		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//(':' type=XType)?
		public Group getGroup_4() { return cGroup_4; }
		
		//':'
		public Keyword getColonKeyword_4_0() { return cColonKeyword_4_0; }
		
		//type=XType
		public Assignment getTypeAssignment_4_1() { return cTypeAssignment_4_1; }
		
		//XType
		public RuleCall getTypeXTypeParserRuleCall_4_1_0() { return cTypeXTypeParserRuleCall_4_1_0; }
		
		//('=' value=XFormula)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'='
		public Keyword getEqualsSignKeyword_5_0() { return cEqualsSignKeyword_5_0; }
		
		//value=XFormula
		public Assignment getValueAssignment_5_1() { return cValueAssignment_5_1; }
		
		//XFormula
		public RuleCall getValueXFormulaParserRuleCall_5_1_0() { return cValueXFormulaParserRuleCall_5_1_0; }
	}
	public class XAxiomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XAxiom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAxiomAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameXLABELTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cPredicateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPredicateXFormulaParserRuleCall_3_0 = (RuleCall)cPredicateAssignment_3.eContents().get(0);
		
		//XAxiom returns econtext::Axiom:
		//    {econtext::Axiom}
		//    (comment = STRING)?
		//    name=XLABEL predicate=XFormula
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Axiom}
		//(comment = STRING)?
		//name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//{econtext::Axiom}
		public Action getAxiomAction_0() { return cAxiomAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=XLABEL
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_2_0() { return cNameXLABELTerminalRuleCall_2_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_3() { return cPredicateAssignment_3; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_3_0() { return cPredicateXFormulaParserRuleCall_3_0; }
	}
	public class XIndividualAxiomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XIndividualAxiom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAxiomAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cAxiomKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cAxmKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameXLABELTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cPredicateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPredicateXFormulaParserRuleCall_4_0 = (RuleCall)cPredicateAssignment_4.eContents().get(0);
		
		//XIndividualAxiom returns econtext::Axiom:
		//    {econtext::Axiom}
		//    (comment = STRING)?
		//    ('axiom' | 'axm') name=XLABEL predicate=XFormula
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Axiom}
		//(comment = STRING)?
		//('axiom' | 'axm') name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//{econtext::Axiom}
		public Action getAxiomAction_0() { return cAxiomAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//('axiom' | 'axm')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'axiom'
		public Keyword getAxiomKeyword_2_0() { return cAxiomKeyword_2_0; }
		
		//'axm'
		public Keyword getAxmKeyword_2_1() { return cAxmKeyword_2_1; }
		
		//name=XLABEL
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_3_0() { return cNameXLABELTerminalRuleCall_3_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_4() { return cPredicateAssignment_4; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_4_0() { return cPredicateXFormulaParserRuleCall_4_0; }
	}
	public class XIndividualTheoremElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XIndividualTheorem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAxiomAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cTheoremAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cTheoremAlternatives_2_0 = (Alternatives)cTheoremAssignment_2.eContents().get(0);
		private final Keyword cTheoremTheoremKeyword_2_0_0 = (Keyword)cTheoremAlternatives_2_0.eContents().get(0);
		private final Keyword cTheoremThmKeyword_2_0_1 = (Keyword)cTheoremAlternatives_2_0.eContents().get(1);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameXLABELTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cPredicateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPredicateXFormulaParserRuleCall_4_0 = (RuleCall)cPredicateAssignment_4.eContents().get(0);
		
		//XIndividualTheorem returns econtext::Axiom:
		//    {econtext::Axiom}
		//    (comment = STRING)?
		//    theorem?=('theorem' | 'thm') name=XLABEL predicate=XFormula
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{econtext::Axiom}
		//(comment = STRING)?
		//theorem?=('theorem' | 'thm') name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//{econtext::Axiom}
		public Action getAxiomAction_0() { return cAxiomAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//theorem?=('theorem' | 'thm')
		public Assignment getTheoremAssignment_2() { return cTheoremAssignment_2; }
		
		//('theorem' | 'thm')
		public Alternatives getTheoremAlternatives_2_0() { return cTheoremAlternatives_2_0; }
		
		//'theorem'
		public Keyword getTheoremTheoremKeyword_2_0_0() { return cTheoremTheoremKeyword_2_0_0; }
		
		//'thm'
		public Keyword getTheoremThmKeyword_2_0_1() { return cTheoremThmKeyword_2_0_1; }
		
		//name=XLABEL
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_3_0() { return cNameXLABELTerminalRuleCall_3_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_4() { return cPredicateAssignment_4; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_4_0() { return cPredicateXFormulaParserRuleCall_4_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIDTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cUNTRANSLATED_TOKENTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//XFormula returns ecore::EString:
		//    (
		//        EVENTB_IDENTIFIER_KEYWORD |
		//        EVENTB_PREDICATE_SYMBOLS |
		//        EVENTB_EXPRESSION_SYMBOLS |
		//        ID |
		//        INT |
		//        UNTRANSLATED_TOKEN
		//    )+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//    EVENTB_IDENTIFIER_KEYWORD |
		//    EVENTB_PREDICATE_SYMBOLS |
		//    EVENTB_EXPRESSION_SYMBOLS |
		//    ID |
		//    INT |
		//    UNTRANSLATED_TOKEN
		//)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EVENTB_IDENTIFIER_KEYWORD
		public RuleCall getEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0() { return cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_0; }
		
		//EVENTB_PREDICATE_SYMBOLS
		public RuleCall getEVENTB_PREDICATE_SYMBOLSParserRuleCall_1() { return cEVENTB_PREDICATE_SYMBOLSParserRuleCall_1; }
		
		//EVENTB_EXPRESSION_SYMBOLS
		public RuleCall getEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2() { return cEVENTB_EXPRESSION_SYMBOLSParserRuleCall_2; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_3() { return cIDTerminalRuleCall_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
		
		//UNTRANSLATED_TOKEN
		public RuleCall getUNTRANSLATED_TOKENTerminalRuleCall_5() { return cUNTRANSLATED_TOKENTerminalRuleCall_5; }
	}
	public class XTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXTypePrimitiveParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cXTYPEOPERATORParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cXTypePrimitiveParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//XType returns ecore::EString:
		//    XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*
		public Group getGroup() { return cGroup; }
		
		//XTypePrimitive
		public RuleCall getXTypePrimitiveParserRuleCall_0() { return cXTypePrimitiveParserRuleCall_0; }
		
		//(XTYPEOPERATOR XTypePrimitive)*
		public Group getGroup_1() { return cGroup_1; }
		
		//XTYPEOPERATOR
		public RuleCall getXTYPEOPERATORParserRuleCall_1_0() { return cXTYPEOPERATORParserRuleCall_1_0; }
		
		//XTypePrimitive
		public RuleCall getXTypePrimitiveParserRuleCall_1_1() { return cXTypePrimitiveParserRuleCall_1_1; }
	}
	public class XTYPEOPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XTYPEOPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPrivateUseAreaE100Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE101Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE102Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsArrowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithTailWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cMultiplicationSignKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//XTYPEOPERATOR returns ecore::EString:
		//    '↔' | // Symbols for building set of relations
		//    '' |
		//    '' |
		//    '' |
		//    '⇸' |
		//    '→' |
		//    '⤔' |
		//    '↣' |
		//    '⤀' |
		//    '↠' |
		//    '⤖' |
		//    '×'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'↔' | // Symbols for building set of relations
		//'' |
		//'' |
		//'' |
		//'⇸' |
		//'→' |
		//'⤔' |
		//'↣' |
		//'⤀' |
		//'↠' |
		//'⤖' |
		//'×'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_0() { return cLeftRightArrowKeyword_0; }
		
		//// Symbols for building set of relations
		//   ''
		public Keyword getPrivateUseAreaE100Keyword_1() { return cPrivateUseAreaE100Keyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE101Keyword_2() { return cPrivateUseAreaE101Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_3() { return cPrivateUseAreaE102Keyword_3; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_4() { return cRightwardsArrowWithVerticalStrokeKeyword_4; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_5() { return cRightwardsArrowKeyword_5; }
		
		//'⤔'
		public Keyword getRightwardsArrowWithTailWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithTailWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_10() { return cRightwardsTwoHeadedArrowWithTailKeyword_10; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_11() { return cMultiplicationSignKeyword_11; }
	}
	public class XTypePrimitiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XTypePrimitive");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cBOOLKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDoubleStruckCapitalNDigitOneKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDoubleStruckCapitalNKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDoubleStruckCapitalZKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cXTypeParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Keyword cDoubleStruckCapitalPKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final RuleCall cXTypeParserRuleCall_6_2 = (RuleCall)cGroup_6.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Keyword cDoubleStruckCapitalPDigitOneKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final RuleCall cXTypeParserRuleCall_7_2 = (RuleCall)cGroup_7.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_7_3 = (Keyword)cGroup_7.eContents().get(3);
		
		//XTypePrimitive returns ecore::EString:
		//    ID |
		//    'BOOL' |
		//    'ℕ1' |
		//    'ℕ' |
		//    'ℤ' |
		//    '(' XType ')'|
		//    'ℙ' '(' XType ')' |
		//    'ℙ1' '(' XType ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ID |
		//'BOOL' |
		//'ℕ1' |
		//'ℕ' |
		//'ℤ' |
		//'(' XType ')'|
		//'ℙ' '(' XType ')' |
		//'ℙ1' '(' XType ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_1() { return cBOOLKeyword_1; }
		
		//'ℕ1'
		public Keyword getDoubleStruckCapitalNDigitOneKeyword_2() { return cDoubleStruckCapitalNDigitOneKeyword_2; }
		
		//'ℕ'
		public Keyword getDoubleStruckCapitalNKeyword_3() { return cDoubleStruckCapitalNKeyword_3; }
		
		//'ℤ'
		public Keyword getDoubleStruckCapitalZKeyword_4() { return cDoubleStruckCapitalZKeyword_4; }
		
		//'(' XType ')'
		public Group getGroup_5() { return cGroup_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_5_1() { return cXTypeParserRuleCall_5_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }
		
		//'ℙ' '(' XType ')'
		public Group getGroup_6() { return cGroup_6; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_6_0() { return cDoubleStruckCapitalPKeyword_6_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6_1() { return cLeftParenthesisKeyword_6_1; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_6_2() { return cXTypeParserRuleCall_6_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6_3() { return cRightParenthesisKeyword_6_3; }
		
		//'ℙ1' '(' XType ')'
		public Group getGroup_7() { return cGroup_7; }
		
		//'ℙ1'
		public Keyword getDoubleStruckCapitalPDigitOneKeyword_7_0() { return cDoubleStruckCapitalPDigitOneKeyword_7_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_7_1() { return cLeftParenthesisKeyword_7_1; }
		
		//XType
		public RuleCall getXTypeParserRuleCall_7_2() { return cXTypeParserRuleCall_7_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7_3() { return cRightParenthesisKeyword_7_3; }
	}
	public class EVENTB_IDENTIFIER_KEYWORDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_IDENTIFIER_KEYWORD");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOOLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFALSEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTRUEKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBoolKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cCardKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDomKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cFiniteKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cIdKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cInterKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMaxKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cMinKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cModKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cPredKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cPrj1Keyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cPrj2Keyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cRanKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cSuccKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cUnionKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cDoubleStruckCapitalNDigitOneKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cDoubleStruckCapitalNKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cDoubleStruckCapitalPDigitOneKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cDoubleStruckCapitalPKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cDoubleStruckCapitalZKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		
		//// IMPORTANT: Do not make these terminal as it can cause problem with the XType
		//EVENTB_IDENTIFIER_KEYWORD returns ecore::EString:
		//    'BOOL' |
		//    'FALSE' |
		//    'TRUE' |
		//    'bool' |
		//    'card' |
		//    'dom' |
		//    'finite' |
		//    'id' |
		//    'inter' |
		//    'max' |
		//    'min' |
		//    'mod' |
		//    'pred' |
		//    'prj1' |
		//    'prj2' |
		//    'ran' |
		//    'succ' |
		//    'union' |
		//    'ℕ1' |
		//    'ℕ' |
		//    'ℙ1' |
		//    'ℙ' |
		//    'ℤ'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'BOOL' |
		//'FALSE' |
		//'TRUE' |
		//'bool' |
		//'card' |
		//'dom' |
		//'finite' |
		//'id' |
		//'inter' |
		//'max' |
		//'min' |
		//'mod' |
		//'pred' |
		//'prj1' |
		//'prj2' |
		//'ran' |
		//'succ' |
		//'union' |
		//'ℕ1' |
		//'ℕ' |
		//'ℙ1' |
		//'ℙ' |
		//'ℤ'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_0() { return cBOOLKeyword_0; }
		
		//'FALSE'
		public Keyword getFALSEKeyword_1() { return cFALSEKeyword_1; }
		
		//'TRUE'
		public Keyword getTRUEKeyword_2() { return cTRUEKeyword_2; }
		
		//'bool'
		public Keyword getBoolKeyword_3() { return cBoolKeyword_3; }
		
		//'card'
		public Keyword getCardKeyword_4() { return cCardKeyword_4; }
		
		//'dom'
		public Keyword getDomKeyword_5() { return cDomKeyword_5; }
		
		//'finite'
		public Keyword getFiniteKeyword_6() { return cFiniteKeyword_6; }
		
		//'id'
		public Keyword getIdKeyword_7() { return cIdKeyword_7; }
		
		//'inter'
		public Keyword getInterKeyword_8() { return cInterKeyword_8; }
		
		//'max'
		public Keyword getMaxKeyword_9() { return cMaxKeyword_9; }
		
		//'min'
		public Keyword getMinKeyword_10() { return cMinKeyword_10; }
		
		//'mod'
		public Keyword getModKeyword_11() { return cModKeyword_11; }
		
		//'pred'
		public Keyword getPredKeyword_12() { return cPredKeyword_12; }
		
		//'prj1'
		public Keyword getPrj1Keyword_13() { return cPrj1Keyword_13; }
		
		//'prj2'
		public Keyword getPrj2Keyword_14() { return cPrj2Keyword_14; }
		
		//'ran'
		public Keyword getRanKeyword_15() { return cRanKeyword_15; }
		
		//'succ'
		public Keyword getSuccKeyword_16() { return cSuccKeyword_16; }
		
		//'union'
		public Keyword getUnionKeyword_17() { return cUnionKeyword_17; }
		
		//'ℕ1'
		public Keyword getDoubleStruckCapitalNDigitOneKeyword_18() { return cDoubleStruckCapitalNDigitOneKeyword_18; }
		
		//'ℕ'
		public Keyword getDoubleStruckCapitalNKeyword_19() { return cDoubleStruckCapitalNKeyword_19; }
		
		//'ℙ1'
		public Keyword getDoubleStruckCapitalPDigitOneKeyword_20() { return cDoubleStruckCapitalPDigitOneKeyword_20; }
		
		//'ℙ'
		public Keyword getDoubleStruckCapitalPKeyword_21() { return cDoubleStruckCapitalPKeyword_21; }
		
		//'ℤ'
		public Keyword getDoubleStruckCapitalZKeyword_22() { return cDoubleStruckCapitalZKeyword_22; }
	}
	public class EVENTB_PREDICATE_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_PREDICATE_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeftRightDoubleArrowKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cRightwardsDoubleArrowKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLogicalAndKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAmpersandKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLogicalOrKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cNotSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDownTackKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cUpTackKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cForAllKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cExclamationMarkKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cThereExistsKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cNumberSignKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cCommaKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cMiddleDotKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cFullStopKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cEqualsSignKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cNotEqualToKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLessThanOrEqualToKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cLessThanSignKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cGreaterThanOrEqualToKeyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cGreaterThanSignKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cElementOfKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cColonKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cNotAnElementOfKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cSubsetOfKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cNotASubsetOfKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cSubsetOfOrEqualToKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cNeitherASubsetOfNorEqualToKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cPartitionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		
		//EVENTB_PREDICATE_SYMBOLS returns ecore::EString:
		//    '(' | // Predicate calculus symbols
		//    ')' |
		//    '⇔' |
		//    '⇒' |
		//    '∧' | '&' |
		//    '∨' |
		//    '¬' |
		//    '⊤' |
		//    '⊥' |
		//    '∀' | '!' |
		//    '∃' | '#' |
		//    ',' |
		//    '·' | '.' |
		//    '=' | // Build predicates from expressions
		//    '≠' |
		//    '≤' |
		//    '<' |
		//    '≥' |
		//    '>' |
		//    '∈' | ':' | // Include this for Rodin keyboard
		//    '∉' |
		//    '⊂' |
		//    '⊄' |
		//    '⊆' |
		//    '⊈' |
		//    'partition' // This is missing from the Rodin D7 deliverable
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' | // Predicate calculus symbols
		//')' |
		//'⇔' |
		//'⇒' |
		//'∧' | '&' |
		//'∨' |
		//'¬' |
		//'⊤' |
		//'⊥' |
		//'∀' | '!' |
		//'∃' | '#' |
		//',' |
		//'·' | '.' |
		//'=' | // Build predicates from expressions
		//'≠' |
		//'≤' |
		//'<' |
		//'≥' |
		//'>' |
		//'∈' | ':' | // Include this for Rodin keyboard
		//'∉' |
		//'⊂' |
		//'⊄' |
		//'⊆' |
		//'⊈' |
		//'partition'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//// Predicate calculus symbols
		//   ')'
		public Keyword getRightParenthesisKeyword_1() { return cRightParenthesisKeyword_1; }
		
		//'⇔'
		public Keyword getLeftRightDoubleArrowKeyword_2() { return cLeftRightDoubleArrowKeyword_2; }
		
		//'⇒'
		public Keyword getRightwardsDoubleArrowKeyword_3() { return cRightwardsDoubleArrowKeyword_3; }
		
		//'∧'
		public Keyword getLogicalAndKeyword_4() { return cLogicalAndKeyword_4; }
		
		//'&'
		public Keyword getAmpersandKeyword_5() { return cAmpersandKeyword_5; }
		
		//'∨'
		public Keyword getLogicalOrKeyword_6() { return cLogicalOrKeyword_6; }
		
		//'¬'
		public Keyword getNotSignKeyword_7() { return cNotSignKeyword_7; }
		
		//'⊤'
		public Keyword getDownTackKeyword_8() { return cDownTackKeyword_8; }
		
		//'⊥'
		public Keyword getUpTackKeyword_9() { return cUpTackKeyword_9; }
		
		//'∀'
		public Keyword getForAllKeyword_10() { return cForAllKeyword_10; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_11() { return cExclamationMarkKeyword_11; }
		
		//'∃'
		public Keyword getThereExistsKeyword_12() { return cThereExistsKeyword_12; }
		
		//'#'
		public Keyword getNumberSignKeyword_13() { return cNumberSignKeyword_13; }
		
		//','
		public Keyword getCommaKeyword_14() { return cCommaKeyword_14; }
		
		//'·'
		public Keyword getMiddleDotKeyword_15() { return cMiddleDotKeyword_15; }
		
		//'.'
		public Keyword getFullStopKeyword_16() { return cFullStopKeyword_16; }
		
		//'='
		public Keyword getEqualsSignKeyword_17() { return cEqualsSignKeyword_17; }
		
		//// Build predicates from expressions
		//   '≠'
		public Keyword getNotEqualToKeyword_18() { return cNotEqualToKeyword_18; }
		
		//'≤'
		public Keyword getLessThanOrEqualToKeyword_19() { return cLessThanOrEqualToKeyword_19; }
		
		//'<'
		public Keyword getLessThanSignKeyword_20() { return cLessThanSignKeyword_20; }
		
		//'≥'
		public Keyword getGreaterThanOrEqualToKeyword_21() { return cGreaterThanOrEqualToKeyword_21; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_22() { return cGreaterThanSignKeyword_22; }
		
		//'∈'
		public Keyword getElementOfKeyword_23() { return cElementOfKeyword_23; }
		
		//':'
		public Keyword getColonKeyword_24() { return cColonKeyword_24; }
		
		//// Include this for Rodin keyboard
		//   '∉'
		public Keyword getNotAnElementOfKeyword_25() { return cNotAnElementOfKeyword_25; }
		
		//'⊂'
		public Keyword getSubsetOfKeyword_26() { return cSubsetOfKeyword_26; }
		
		//'⊄'
		public Keyword getNotASubsetOfKeyword_27() { return cNotASubsetOfKeyword_27; }
		
		//'⊆'
		public Keyword getSubsetOfOrEqualToKeyword_28() { return cSubsetOfOrEqualToKeyword_28; }
		
		//'⊈'
		public Keyword getNeitherASubsetOfNorEqualToKeyword_29() { return cNeitherASubsetOfNorEqualToKeyword_29; }
		
		//'partition'
		public Keyword getPartitionKeyword_30() { return cPartitionKeyword_30; }
	}
	public class EVENTB_EXPRESSION_SYMBOLSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.EVENTB_EXPRESSION_SYMBOLS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLeftRightArrowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPrivateUseAreaE100Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPrivateUseAreaE101Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cPrivateUseAreaE102Keyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightwardsArrowWithVerticalStrokeKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRightwardsArrowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightwardsArrowWithTailWithVerticalStrokeKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cRightwardsArrowWithTailKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cRightwardsTwoHeadedArrowKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cRightwardsTwoHeadedArrowWithTailKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cLeftCurlyBracketKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cRightCurlyBracketKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cRightwardsArrowFromBarKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cEmptySetKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cIntersectionKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final Keyword cUnionKeyword_16 = (Keyword)cAlternatives.eContents().get(16);
		private final Keyword cSetMinusKeyword_17 = (Keyword)cAlternatives.eContents().get(17);
		private final Keyword cMultiplicationSignKeyword_18 = (Keyword)cAlternatives.eContents().get(18);
		private final Keyword cLeftSquareBracketKeyword_19 = (Keyword)cAlternatives.eContents().get(19);
		private final Keyword cRightSquareBracketKeyword_20 = (Keyword)cAlternatives.eContents().get(20);
		private final Keyword cPrivateUseAreaE103Keyword_21 = (Keyword)cAlternatives.eContents().get(21);
		private final Keyword cRingOperatorKeyword_22 = (Keyword)cAlternatives.eContents().get(22);
		private final Keyword cSemicolonKeyword_23 = (Keyword)cAlternatives.eContents().get(23);
		private final Keyword cCircledTimesKeyword_24 = (Keyword)cAlternatives.eContents().get(24);
		private final Keyword cParallelToKeyword_25 = (Keyword)cAlternatives.eContents().get(25);
		private final Keyword cTildeOperatorKeyword_26 = (Keyword)cAlternatives.eContents().get(26);
		private final Keyword cWhiteLeftPointingTriangleKeyword_27 = (Keyword)cAlternatives.eContents().get(27);
		private final Keyword cZNotationDomainAntirestrictionKeyword_28 = (Keyword)cAlternatives.eContents().get(28);
		private final Keyword cWhiteRightPointingTriangleKeyword_29 = (Keyword)cAlternatives.eContents().get(29);
		private final Keyword cZNotationRangeAntirestrictionKeyword_30 = (Keyword)cAlternatives.eContents().get(30);
		private final Keyword cGreekSmallLetterLamdaKeyword_31 = (Keyword)cAlternatives.eContents().get(31);
		private final Group cGroup_32 = (Group)cAlternatives.eContents().get(32);
		private final Keyword cPercentSignKeyword_32_0 = (Keyword)cGroup_32.eContents().get(0);
		private final Keyword cNAryIntersectionKeyword_32_1 = (Keyword)cGroup_32.eContents().get(1);
		private final Keyword cNAryUnionKeyword_33 = (Keyword)cAlternatives.eContents().get(33);
		private final Keyword cDividesKeyword_34 = (Keyword)cAlternatives.eContents().get(34);
		private final Keyword cTwoDotLeaderKeyword_35 = (Keyword)cAlternatives.eContents().get(35);
		private final Keyword cPlusSignKeyword_36 = (Keyword)cAlternatives.eContents().get(36);
		private final Keyword cMinusSignKeyword_37 = (Keyword)cAlternatives.eContents().get(37);
		private final Keyword cHyphenMinusKeyword_38 = (Keyword)cAlternatives.eContents().get(38);
		private final Keyword cAsteriskOperatorKeyword_39 = (Keyword)cAlternatives.eContents().get(39);
		private final Keyword cAsteriskKeyword_40 = (Keyword)cAlternatives.eContents().get(40);
		private final Keyword cDivisionSignKeyword_41 = (Keyword)cAlternatives.eContents().get(41);
		private final Keyword cSolidusKeyword_42 = (Keyword)cAlternatives.eContents().get(42);
		private final Keyword cCircumflexAccentKeyword_43 = (Keyword)cAlternatives.eContents().get(43);
		private final Keyword cBackslashKeyword_44 = (Keyword)cAlternatives.eContents().get(44);
		
		//EVENTB_EXPRESSION_SYMBOLS returns ecore::EString:
		//    '↔' | // Symbols for building set of relations
		//    '' |
		//    '' |
		//    '' |
		//    '⇸' |
		//    '→' |
		//    '⤔' |
		//    '↣' |
		//    '⤀' |
		//    '↠' |
		//    '⤖' |
		//    '{' | // Symbols for manipulating sets
		//    '}' |
		//    '↦' |
		//    '∅' |
		//    '∩' |
		//    '∪' |
		//    '∖' |
		//    '×' |
		//    '[' | // Symbols for manipulating functions and relations
		//    ']' |
		//    '' |
		//    '∘' |
		//    ';' |
		//    '⊗' |
		//    '∥' |
		//    '∼' |
		//    '◁' |
		//    '⩤' |
		//    '▷' |
		//    '⩥' |
		//    'λ' | '%' // Symbols for quantified expressions
		//    '⋂' |
		//    '⋃' |
		//    '∣' |
		//    '‥' | // Symbols for arithmetic expressions
		//    '+' |
		//    '−' | '-' |
		//    '∗' | '*' |
		//    '÷' | '/' |
		//    '^' |
		//    '\\' // Allowed for LaTeX combos
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'↔' | // Symbols for building set of relations
		//'' |
		//'' |
		//'' |
		//'⇸' |
		//'→' |
		//'⤔' |
		//'↣' |
		//'⤀' |
		//'↠' |
		//'⤖' |
		//'{' | // Symbols for manipulating sets
		//'}' |
		//'↦' |
		//'∅' |
		//'∩' |
		//'∪' |
		//'∖' |
		//'×' |
		//'[' | // Symbols for manipulating functions and relations
		//']' |
		//'' |
		//'∘' |
		//';' |
		//'⊗' |
		//'∥' |
		//'∼' |
		//'◁' |
		//'⩤' |
		//'▷' |
		//'⩥' |
		//'λ' | '%' // Symbols for quantified expressions
		//'⋂' |
		//'⋃' |
		//'∣' |
		//'‥' | // Symbols for arithmetic expressions
		//'+' |
		//'−' | '-' |
		//'∗' | '*' |
		//'÷' | '/' |
		//'^' |
		//'\\'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'↔'
		public Keyword getLeftRightArrowKeyword_0() { return cLeftRightArrowKeyword_0; }
		
		//// Symbols for building set of relations
		//   ''
		public Keyword getPrivateUseAreaE100Keyword_1() { return cPrivateUseAreaE100Keyword_1; }
		
		//''
		public Keyword getPrivateUseAreaE101Keyword_2() { return cPrivateUseAreaE101Keyword_2; }
		
		//''
		public Keyword getPrivateUseAreaE102Keyword_3() { return cPrivateUseAreaE102Keyword_3; }
		
		//'⇸'
		public Keyword getRightwardsArrowWithVerticalStrokeKeyword_4() { return cRightwardsArrowWithVerticalStrokeKeyword_4; }
		
		//'→'
		public Keyword getRightwardsArrowKeyword_5() { return cRightwardsArrowKeyword_5; }
		
		//'⤔'
		public Keyword getRightwardsArrowWithTailWithVerticalStrokeKeyword_6() { return cRightwardsArrowWithTailWithVerticalStrokeKeyword_6; }
		
		//'↣'
		public Keyword getRightwardsArrowWithTailKeyword_7() { return cRightwardsArrowWithTailKeyword_7; }
		
		//'⤀'
		public Keyword getRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8() { return cRightwardsTwoHeadedArrowWithVerticalStrokeKeyword_8; }
		
		//'↠'
		public Keyword getRightwardsTwoHeadedArrowKeyword_9() { return cRightwardsTwoHeadedArrowKeyword_9; }
		
		//'⤖'
		public Keyword getRightwardsTwoHeadedArrowWithTailKeyword_10() { return cRightwardsTwoHeadedArrowWithTailKeyword_10; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_11() { return cLeftCurlyBracketKeyword_11; }
		
		//// Symbols for manipulating sets
		//   '}'
		public Keyword getRightCurlyBracketKeyword_12() { return cRightCurlyBracketKeyword_12; }
		
		//'↦'
		public Keyword getRightwardsArrowFromBarKeyword_13() { return cRightwardsArrowFromBarKeyword_13; }
		
		//'∅'
		public Keyword getEmptySetKeyword_14() { return cEmptySetKeyword_14; }
		
		//'∩'
		public Keyword getIntersectionKeyword_15() { return cIntersectionKeyword_15; }
		
		//'∪'
		public Keyword getUnionKeyword_16() { return cUnionKeyword_16; }
		
		//'∖'
		public Keyword getSetMinusKeyword_17() { return cSetMinusKeyword_17; }
		
		//'×'
		public Keyword getMultiplicationSignKeyword_18() { return cMultiplicationSignKeyword_18; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_19() { return cLeftSquareBracketKeyword_19; }
		
		//// Symbols for manipulating functions and relations
		//   ']'
		public Keyword getRightSquareBracketKeyword_20() { return cRightSquareBracketKeyword_20; }
		
		//''
		public Keyword getPrivateUseAreaE103Keyword_21() { return cPrivateUseAreaE103Keyword_21; }
		
		//'∘'
		public Keyword getRingOperatorKeyword_22() { return cRingOperatorKeyword_22; }
		
		//';'
		public Keyword getSemicolonKeyword_23() { return cSemicolonKeyword_23; }
		
		//'⊗'
		public Keyword getCircledTimesKeyword_24() { return cCircledTimesKeyword_24; }
		
		//'∥'
		public Keyword getParallelToKeyword_25() { return cParallelToKeyword_25; }
		
		//'∼'
		public Keyword getTildeOperatorKeyword_26() { return cTildeOperatorKeyword_26; }
		
		//'◁'
		public Keyword getWhiteLeftPointingTriangleKeyword_27() { return cWhiteLeftPointingTriangleKeyword_27; }
		
		//'⩤'
		public Keyword getZNotationDomainAntirestrictionKeyword_28() { return cZNotationDomainAntirestrictionKeyword_28; }
		
		//'▷'
		public Keyword getWhiteRightPointingTriangleKeyword_29() { return cWhiteRightPointingTriangleKeyword_29; }
		
		//'⩥'
		public Keyword getZNotationRangeAntirestrictionKeyword_30() { return cZNotationRangeAntirestrictionKeyword_30; }
		
		//'λ'
		public Keyword getGreekSmallLetterLamdaKeyword_31() { return cGreekSmallLetterLamdaKeyword_31; }
		
		//'%' // Symbols for quantified expressions
		//   '⋂'
		public Group getGroup_32() { return cGroup_32; }
		
		//'%'
		public Keyword getPercentSignKeyword_32_0() { return cPercentSignKeyword_32_0; }
		
		//// Symbols for quantified expressions
		//   '⋂'
		public Keyword getNAryIntersectionKeyword_32_1() { return cNAryIntersectionKeyword_32_1; }
		
		//'⋃'
		public Keyword getNAryUnionKeyword_33() { return cNAryUnionKeyword_33; }
		
		//'∣'
		public Keyword getDividesKeyword_34() { return cDividesKeyword_34; }
		
		//'‥'
		public Keyword getTwoDotLeaderKeyword_35() { return cTwoDotLeaderKeyword_35; }
		
		//// Symbols for arithmetic expressions
		//   '+'
		public Keyword getPlusSignKeyword_36() { return cPlusSignKeyword_36; }
		
		//'−'
		public Keyword getMinusSignKeyword_37() { return cMinusSignKeyword_37; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_38() { return cHyphenMinusKeyword_38; }
		
		//'∗'
		public Keyword getAsteriskOperatorKeyword_39() { return cAsteriskOperatorKeyword_39; }
		
		//'*'
		public Keyword getAsteriskKeyword_40() { return cAsteriskKeyword_40; }
		
		//'÷'
		public Keyword getDivisionSignKeyword_41() { return cDivisionSignKeyword_41; }
		
		//'/'
		public Keyword getSolidusKeyword_42() { return cSolidusKeyword_42; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_43() { return cCircumflexAccentKeyword_43; }
		
		//'\\'
		public Keyword getBackslashKeyword_44() { return cBackslashKeyword_44; }
	}
	public class XRecordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XRecord");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRecordAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExtendedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cExtendedExtendedKeyword_1_0 = (Keyword)cExtendedAssignment_1.eContents().get(0);
		private final Keyword cRecordKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cInheritsKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cInheritsNamesAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cInheritsNamesIDTerminalRuleCall_4_1_0 = (RuleCall)cInheritsNamesAssignment_4_1.eContents().get(0);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Group cGroup_5_0 = (Group)cAlternatives_5.eContents().get(0);
		private final Keyword cFieldKeyword_5_0_0 = (Keyword)cGroup_5_0.eContents().get(0);
		private final Assignment cFieldsAssignment_5_0_1 = (Assignment)cGroup_5_0.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_5_0_1_0 = (RuleCall)cFieldsAssignment_5_0_1.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cConstraintKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cConstraintsAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cConstraintsXConstraintParserRuleCall_5_1_1_0 = (RuleCall)cConstraintsAssignment_5_1_1.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///*
		// * support for records
		// */
		//XRecord returns erecords::Record:
		//    {erecords::Record}
		//    (extended ?= 'extended')?
		//    'record' name = ID
		//    ('inherits' inheritsNames +=ID)?
		//    ('field' fields += Field | 'constraint' constraints += XConstraint)*
		//    'end'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{erecords::Record}
		//(extended ?= 'extended')?
		//'record' name = ID
		//('inherits' inheritsNames +=ID)?
		//('field' fields += Field | 'constraint' constraints += XConstraint)*
		//'end'
		public Group getGroup() { return cGroup; }
		
		//{erecords::Record}
		public Action getRecordAction_0() { return cRecordAction_0; }
		
		//(extended ?= 'extended')?
		public Assignment getExtendedAssignment_1() { return cExtendedAssignment_1; }
		
		//'extended'
		public Keyword getExtendedExtendedKeyword_1_0() { return cExtendedExtendedKeyword_1_0; }
		
		//'record'
		public Keyword getRecordKeyword_2() { return cRecordKeyword_2; }
		
		//name = ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }
		
		//('inherits' inheritsNames +=ID)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'inherits'
		public Keyword getInheritsKeyword_4_0() { return cInheritsKeyword_4_0; }
		
		//inheritsNames +=ID
		public Assignment getInheritsNamesAssignment_4_1() { return cInheritsNamesAssignment_4_1; }
		
		//ID
		public RuleCall getInheritsNamesIDTerminalRuleCall_4_1_0() { return cInheritsNamesIDTerminalRuleCall_4_1_0; }
		
		//('field' fields += Field | 'constraint' constraints += XConstraint)*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }
		
		//'field' fields += Field
		public Group getGroup_5_0() { return cGroup_5_0; }
		
		//'field'
		public Keyword getFieldKeyword_5_0_0() { return cFieldKeyword_5_0_0; }
		
		//fields += Field
		public Assignment getFieldsAssignment_5_0_1() { return cFieldsAssignment_5_0_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_5_0_1_0() { return cFieldsFieldParserRuleCall_5_0_1_0; }
		
		//'constraint' constraints += XConstraint
		public Group getGroup_5_1() { return cGroup_5_1; }
		
		//'constraint'
		public Keyword getConstraintKeyword_5_1_0() { return cConstraintKeyword_5_1_0; }
		
		//constraints += XConstraint
		public Assignment getConstraintsAssignment_5_1_1() { return cConstraintsAssignment_5_1_1; }
		
		//XConstraint
		public RuleCall getConstraintsXConstraintParserRuleCall_5_1_1_0() { return cConstraintsXConstraintParserRuleCall_5_1_1_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class FieldTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.FieldType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//FieldType returns ecore::EString:
		//    (
		//        ID |
		//        EVENTB_IDENTIFIER_KEYWORD
		//    )
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//(
		//    ID |
		//    EVENTB_IDENTIFIER_KEYWORD
		//)
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//EVENTB_IDENTIFIER_KEYWORD
		public RuleCall getEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1() { return cEVENTB_IDENTIFIER_KEYWORDParserRuleCall_1; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMultiplicityAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMultiplicityMultiplicityEnumRuleCall_4_0 = (RuleCall)cMultiplicityAssignment_4.eContents().get(0);
		private final Assignment cTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTypeFieldTypeParserRuleCall_5_0 = (RuleCall)cTypeAssignment_5.eContents().get(0);
		
		//Field returns erecords::Field:
		//    {erecords::Field}
		//    (comment = STRING)?
		//    name = ID (':')
		//    (multiplicity=Multiplicity)?
		//    (type= FieldType)
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{erecords::Field}
		//(comment = STRING)?
		//name = ID (':')
		//(multiplicity=Multiplicity)?
		//(type= FieldType)
		public Group getGroup() { return cGroup; }
		
		//{erecords::Field}
		public Action getFieldAction_0() { return cFieldAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name = ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//(':')
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//(multiplicity=Multiplicity)?
		public Assignment getMultiplicityAssignment_4() { return cMultiplicityAssignment_4; }
		
		//Multiplicity
		public RuleCall getMultiplicityMultiplicityEnumRuleCall_4_0() { return cMultiplicityMultiplicityEnumRuleCall_4_0; }
		
		//(type= FieldType)
		public Assignment getTypeAssignment_5() { return cTypeAssignment_5; }
		
		//FieldType
		public RuleCall getTypeFieldTypeParserRuleCall_5_0() { return cTypeFieldTypeParserRuleCall_5_0; }
	}
	public class XConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstraintAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentSTRINGTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameXLABELTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cPredicateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPredicateXFormulaParserRuleCall_3_0 = (RuleCall)cPredicateAssignment_3.eContents().get(0);
		
		//XConstraint returns erecords::Constraint:
		//    {erecords::Constraint}
		//    (comment = STRING)?
		//    name=XLABEL predicate=XFormula
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{erecords::Constraint}
		//(comment = STRING)?
		//name=XLABEL predicate=XFormula
		public Group getGroup() { return cGroup; }
		
		//{erecords::Constraint}
		public Action getConstraintAction_0() { return cConstraintAction_0; }
		
		//(comment = STRING)?
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_1_0() { return cCommentSTRINGTerminalRuleCall_1_0; }
		
		//name=XLABEL
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//XLABEL
		public RuleCall getNameXLABELTerminalRuleCall_2_0() { return cNameXLABELTerminalRuleCall_2_0; }
		
		//predicate=XFormula
		public Assignment getPredicateAssignment_3() { return cPredicateAssignment_3; }
		
		//XFormula
		public RuleCall getPredicateXFormulaParserRuleCall_3_0() { return cPredicateXFormulaParserRuleCall_3_0; }
	}
	
	public class MultiplicityElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.Multiplicity");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cONEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cONEOneKeyword_0_0 = (Keyword)cONEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMANYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMANYManyKeyword_1_0 = (Keyword)cMANYEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOPTIONALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOPTIONALOptKeyword_2_0 = (Keyword)cOPTIONALEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Multiplicity returns erecords::Multiplicity:
		//                ONE = 'one' | MANY = 'many' | OPTIONAL = 'opt';
		public EnumRule getRule() { return rule; }
		
		//ONE = 'one' | MANY = 'many' | OPTIONAL = 'opt'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ONE = 'one'
		public EnumLiteralDeclaration getONEEnumLiteralDeclaration_0() { return cONEEnumLiteralDeclaration_0; }
		
		//'one'
		public Keyword getONEOneKeyword_0_0() { return cONEOneKeyword_0_0; }
		
		//MANY = 'many'
		public EnumLiteralDeclaration getMANYEnumLiteralDeclaration_1() { return cMANYEnumLiteralDeclaration_1; }
		
		//'many'
		public Keyword getMANYManyKeyword_1_0() { return cMANYManyKeyword_1_0; }
		
		//OPTIONAL = 'opt'
		public EnumLiteralDeclaration getOPTIONALEnumLiteralDeclaration_2() { return cOPTIONALEnumLiteralDeclaration_2; }
		
		//'opt'
		public Keyword getOPTIONALOptKeyword_2_0() { return cOPTIONALOptKeyword_2_0; }
	}
	
	private final XContextElements pXContext;
	private final QualifiedNameElements pQualifiedName;
	private final XCarrierSetElements pXCarrierSet;
	private final XIndividualCarrierSetElements pXIndividualCarrierSet;
	private final XConstantElements pXConstant;
	private final XIndividualConstantElements pXIndividualConstant;
	private final XAxiomElements pXAxiom;
	private final XIndividualAxiomElements pXIndividualAxiom;
	private final XIndividualTheoremElements pXIndividualTheorem;
	private final TerminalRule tXLABEL;
	private final XFormulaElements pXFormula;
	private final XTypeElements pXType;
	private final XTYPEOPERATORElements pXTYPEOPERATOR;
	private final XTypePrimitiveElements pXTypePrimitive;
	private final EVENTB_IDENTIFIER_KEYWORDElements pEVENTB_IDENTIFIER_KEYWORD;
	private final EVENTB_PREDICATE_SYMBOLSElements pEVENTB_PREDICATE_SYMBOLS;
	private final EVENTB_EXPRESSION_SYMBOLSElements pEVENTB_EXPRESSION_SYMBOLS;
	private final TerminalRule tID;
	private final TerminalRule tUNTRANSLATED_TOKEN;
	private final TerminalRule tSTRING;
	private final XRecordElements pXRecord;
	private final FieldTypeElements pFieldType;
	private final FieldElements pField;
	private final MultiplicityElements eMultiplicity;
	private final XConstraintElements pXConstraint;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public XContextGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pXContext = new XContextElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pXCarrierSet = new XCarrierSetElements();
		this.pXIndividualCarrierSet = new XIndividualCarrierSetElements();
		this.pXConstant = new XConstantElements();
		this.pXIndividualConstant = new XIndividualConstantElements();
		this.pXAxiom = new XAxiomElements();
		this.pXIndividualAxiom = new XIndividualAxiomElements();
		this.pXIndividualTheorem = new XIndividualTheoremElements();
		this.tXLABEL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.XLABEL");
		this.pXFormula = new XFormulaElements();
		this.pXType = new XTypeElements();
		this.pXTYPEOPERATOR = new XTYPEOPERATORElements();
		this.pXTypePrimitive = new XTypePrimitiveElements();
		this.pEVENTB_IDENTIFIER_KEYWORD = new EVENTB_IDENTIFIER_KEYWORDElements();
		this.pEVENTB_PREDICATE_SYMBOLS = new EVENTB_PREDICATE_SYMBOLSElements();
		this.pEVENTB_EXPRESSION_SYMBOLS = new EVENTB_EXPRESSION_SYMBOLSElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.ID");
		this.tUNTRANSLATED_TOKEN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.UNTRANSLATED_TOKEN");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ac.soton.xeventb.xcontext.XContext.STRING");
		this.pXRecord = new XRecordElements();
		this.pFieldType = new FieldTypeElements();
		this.pField = new FieldElements();
		this.eMultiplicity = new MultiplicityElements();
		this.pXConstraint = new XConstraintElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.xeventb.xcontext.XContext".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//XContext returns econtext::Context:
	//    {econtext::Context}
	//    (comment = STRING)?
	//    'context' name=ID
	//    (
	//         // Multiple-extend clause
	//        ('extends' extends+=[econtext::Context |QualifiedName]+) |
	//        // Individual-extend clause
	//        (('extend' | 'ext') extends+=[econtext::Context |QualifiedName]) |
	//        // Multiple-(carrier)set clause
	//        ('sets' orderedChildren+=XCarrierSet+) |
	//        // Individual-(carrier)set clause
	//        (orderedChildren+=XIndividualCarrierSet) |
	//        // Multiple-constant clause
	//        ('constants' orderedChildren+=XConstant+) |
	//        // Individual-constant clause
	//        (orderedChildren+=XIndividualConstant) |
	//        (orderedChildren += XRecord) |
	//        /*
	//         * Multiple-axiom clause
	//         * To avoid ambiguity, theorems is no longer allowed to be a part of "axioms",
	//         * instead, keyword "theorem" will signify an individual theorem.
	//         */
	//        ('axioms' orderedChildren+=XAxiom+) |
	//        // Individual-axiom clause
	//        (orderedChildren+=XIndividualAxiom) |
	//        // Individual-theorem clause
	//        (orderedChildren+=XIndividualTheorem)
	//    )*
	//    // Since CamilleX 3.0, we do not have the final 'end' keyword
	////    'end'
	//;
	public XContextElements getXContextAccess() {
		return pXContext;
	}
	
	public ParserRule getXContextRule() {
		return getXContextAccess().getRule();
	}
	
	//QualifiedName:
	//   ID ('.' ID)*
	// ;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//XCarrierSet returns econtext::CarrierSet:
	//    {econtext::CarrierSet}
	//    (comment = STRING)?
	//    name=ID
	//;
	public XCarrierSetElements getXCarrierSetAccess() {
		return pXCarrierSet;
	}
	
	public ParserRule getXCarrierSetRule() {
		return getXCarrierSetAccess().getRule();
	}
	
	//XIndividualCarrierSet returns econtext::CarrierSet:
	//    {econtext::CarrierSet}
	//    (comment = STRING)?
	//    'set'
	//    name=ID
	//;
	public XIndividualCarrierSetElements getXIndividualCarrierSetAccess() {
		return pXIndividualCarrierSet;
	}
	
	public ParserRule getXIndividualCarrierSetRule() {
		return getXIndividualCarrierSetAccess().getRule();
	}
	
	//XConstant returns econtext::Constant:
	//    {econtext::Constant}
	//    (comment = STRING)?
	//    name=ID
	//;
	public XConstantElements getXConstantAccess() {
		return pXConstant;
	}
	
	public ParserRule getXConstantRule() {
		return getXConstantAccess().getRule();
	}
	
	//XIndividualConstant returns eventbcoreex::TypedConstant:
	//    {eventbcoreex::TypedConstant}
	//    (comment = STRING)?
	//    ('constant' | 'cst')
	//    name=ID (':' type=XType)? ('=' value=XFormula)?
	//;
	public XIndividualConstantElements getXIndividualConstantAccess() {
		return pXIndividualConstant;
	}
	
	public ParserRule getXIndividualConstantRule() {
		return getXIndividualConstantAccess().getRule();
	}
	
	//XAxiom returns econtext::Axiom:
	//    {econtext::Axiom}
	//    (comment = STRING)?
	//    name=XLABEL predicate=XFormula
	//;
	public XAxiomElements getXAxiomAccess() {
		return pXAxiom;
	}
	
	public ParserRule getXAxiomRule() {
		return getXAxiomAccess().getRule();
	}
	
	//XIndividualAxiom returns econtext::Axiom:
	//    {econtext::Axiom}
	//    (comment = STRING)?
	//    ('axiom' | 'axm') name=XLABEL predicate=XFormula
	//;
	public XIndividualAxiomElements getXIndividualAxiomAccess() {
		return pXIndividualAxiom;
	}
	
	public ParserRule getXIndividualAxiomRule() {
		return getXIndividualAxiomAccess().getRule();
	}
	
	//XIndividualTheorem returns econtext::Axiom:
	//    {econtext::Axiom}
	//    (comment = STRING)?
	//    theorem?=('theorem' | 'thm') name=XLABEL predicate=XFormula
	//;
	public XIndividualTheoremElements getXIndividualTheoremAccess() {
		return pXIndividualTheorem;
	}
	
	public ParserRule getXIndividualTheoremRule() {
		return getXIndividualTheoremAccess().getRule();
	}
	
	////
	////XTheorem returns econtext::Axiom:
	////    {econtext::Axiom}
	////    (comment = STRING)?
	////    theorem?='thm' name=XLABEL predicate=XFormula
	////;
	//terminal XLABEL returns ecore::EString:
	//    '@' !(':')+ ':'
	//;
	public TerminalRule getXLABELRule() {
		return tXLABEL;
	}
	
	//XFormula returns ecore::EString:
	//    (
	//        EVENTB_IDENTIFIER_KEYWORD |
	//        EVENTB_PREDICATE_SYMBOLS |
	//        EVENTB_EXPRESSION_SYMBOLS |
	//        ID |
	//        INT |
	//        UNTRANSLATED_TOKEN
	//    )+
	//;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//XType returns ecore::EString:
	//    XTypePrimitive (XTYPEOPERATOR XTypePrimitive)*
	//;
	public XTypeElements getXTypeAccess() {
		return pXType;
	}
	
	public ParserRule getXTypeRule() {
		return getXTypeAccess().getRule();
	}
	
	//XTYPEOPERATOR returns ecore::EString:
	//    '↔' | // Symbols for building set of relations
	//    '' |
	//    '' |
	//    '' |
	//    '⇸' |
	//    '→' |
	//    '⤔' |
	//    '↣' |
	//    '⤀' |
	//    '↠' |
	//    '⤖' |
	//    '×'
	//;
	public XTYPEOPERATORElements getXTYPEOPERATORAccess() {
		return pXTYPEOPERATOR;
	}
	
	public ParserRule getXTYPEOPERATORRule() {
		return getXTYPEOPERATORAccess().getRule();
	}
	
	//XTypePrimitive returns ecore::EString:
	//    ID |
	//    'BOOL' |
	//    'ℕ1' |
	//    'ℕ' |
	//    'ℤ' |
	//    '(' XType ')'|
	//    'ℙ' '(' XType ')' |
	//    'ℙ1' '(' XType ')'
	//;
	public XTypePrimitiveElements getXTypePrimitiveAccess() {
		return pXTypePrimitive;
	}
	
	public ParserRule getXTypePrimitiveRule() {
		return getXTypePrimitiveAccess().getRule();
	}
	
	//// IMPORTANT: Do not make these terminal as it can cause problem with the XType
	//EVENTB_IDENTIFIER_KEYWORD returns ecore::EString:
	//    'BOOL' |
	//    'FALSE' |
	//    'TRUE' |
	//    'bool' |
	//    'card' |
	//    'dom' |
	//    'finite' |
	//    'id' |
	//    'inter' |
	//    'max' |
	//    'min' |
	//    'mod' |
	//    'pred' |
	//    'prj1' |
	//    'prj2' |
	//    'ran' |
	//    'succ' |
	//    'union' |
	//    'ℕ1' |
	//    'ℕ' |
	//    'ℙ1' |
	//    'ℙ' |
	//    'ℤ'
	//;
	public EVENTB_IDENTIFIER_KEYWORDElements getEVENTB_IDENTIFIER_KEYWORDAccess() {
		return pEVENTB_IDENTIFIER_KEYWORD;
	}
	
	public ParserRule getEVENTB_IDENTIFIER_KEYWORDRule() {
		return getEVENTB_IDENTIFIER_KEYWORDAccess().getRule();
	}
	
	//EVENTB_PREDICATE_SYMBOLS returns ecore::EString:
	//    '(' | // Predicate calculus symbols
	//    ')' |
	//    '⇔' |
	//    '⇒' |
	//    '∧' | '&' |
	//    '∨' |
	//    '¬' |
	//    '⊤' |
	//    '⊥' |
	//    '∀' | '!' |
	//    '∃' | '#' |
	//    ',' |
	//    '·' | '.' |
	//    '=' | // Build predicates from expressions
	//    '≠' |
	//    '≤' |
	//    '<' |
	//    '≥' |
	//    '>' |
	//    '∈' | ':' | // Include this for Rodin keyboard
	//    '∉' |
	//    '⊂' |
	//    '⊄' |
	//    '⊆' |
	//    '⊈' |
	//    'partition' // This is missing from the Rodin D7 deliverable
	//;
	public EVENTB_PREDICATE_SYMBOLSElements getEVENTB_PREDICATE_SYMBOLSAccess() {
		return pEVENTB_PREDICATE_SYMBOLS;
	}
	
	public ParserRule getEVENTB_PREDICATE_SYMBOLSRule() {
		return getEVENTB_PREDICATE_SYMBOLSAccess().getRule();
	}
	
	//EVENTB_EXPRESSION_SYMBOLS returns ecore::EString:
	//    '↔' | // Symbols for building set of relations
	//    '' |
	//    '' |
	//    '' |
	//    '⇸' |
	//    '→' |
	//    '⤔' |
	//    '↣' |
	//    '⤀' |
	//    '↠' |
	//    '⤖' |
	//    '{' | // Symbols for manipulating sets
	//    '}' |
	//    '↦' |
	//    '∅' |
	//    '∩' |
	//    '∪' |
	//    '∖' |
	//    '×' |
	//    '[' | // Symbols for manipulating functions and relations
	//    ']' |
	//    '' |
	//    '∘' |
	//    ';' |
	//    '⊗' |
	//    '∥' |
	//    '∼' |
	//    '◁' |
	//    '⩤' |
	//    '▷' |
	//    '⩥' |
	//    'λ' | '%' // Symbols for quantified expressions
	//    '⋂' |
	//    '⋃' |
	//    '∣' |
	//    '‥' | // Symbols for arithmetic expressions
	//    '+' |
	//    '−' | '-' |
	//    '∗' | '*' |
	//    '÷' | '/' |
	//    '^' |
	//    '\\' // Allowed for LaTeX combos
	//;
	public EVENTB_EXPRESSION_SYMBOLSElements getEVENTB_EXPRESSION_SYMBOLSAccess() {
		return pEVENTB_EXPRESSION_SYMBOLS;
	}
	
	public ParserRule getEVENTB_EXPRESSION_SYMBOLSRule() {
		return getEVENTB_EXPRESSION_SYMBOLSAccess().getRule();
	}
	
	//@Override
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_'| 'i'..'ￜ') ('a'..'z'|'A'..'Z'|'_'| 'i'..'ￜ'|'0'..'9' | "'")*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//// This to allow untranslated mathematical symbols in XFormula
	//terminal UNTRANSLATED_TOKEN: ('!'|'#'|'%'|'&'|'*'|'-'|':'|'|'|'\\'|','|'~'|'/'|'.')+;
	public TerminalRule getUNTRANSLATED_TOKENRule() {
		return tUNTRANSLATED_TOKEN;
	}
	
	//@Override
	//terminal STRING: '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	///*
	// * support for records
	// */
	//XRecord returns erecords::Record:
	//    {erecords::Record}
	//    (extended ?= 'extended')?
	//    'record' name = ID
	//    ('inherits' inheritsNames +=ID)?
	//    ('field' fields += Field | 'constraint' constraints += XConstraint)*
	//    'end'
	//;
	public XRecordElements getXRecordAccess() {
		return pXRecord;
	}
	
	public ParserRule getXRecordRule() {
		return getXRecordAccess().getRule();
	}
	
	//FieldType returns ecore::EString:
	//    (
	//        ID |
	//        EVENTB_IDENTIFIER_KEYWORD
	//    )
	//;
	public FieldTypeElements getFieldTypeAccess() {
		return pFieldType;
	}
	
	public ParserRule getFieldTypeRule() {
		return getFieldTypeAccess().getRule();
	}
	
	//Field returns erecords::Field:
	//    {erecords::Field}
	//    (comment = STRING)?
	//    name = ID (':')
	//    (multiplicity=Multiplicity)?
	//    (type= FieldType)
	//;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//enum Multiplicity returns erecords::Multiplicity:
	//                ONE = 'one' | MANY = 'many' | OPTIONAL = 'opt';
	public MultiplicityElements getMultiplicityAccess() {
		return eMultiplicity;
	}
	
	public EnumRule getMultiplicityRule() {
		return getMultiplicityAccess().getRule();
	}
	
	//XConstraint returns erecords::Constraint:
	//    {erecords::Constraint}
	//    (comment = STRING)?
	//    name=XLABEL predicate=XFormula
	//;
	public XConstraintElements getXConstraintAccess() {
		return pXConstraint;
	}
	
	public ParserRule getXConstraintRule() {
		return getXConstraintAccess().getRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
